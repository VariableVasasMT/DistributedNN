<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Distributed Neural Network WASM Demo with Blockchain</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }
        
        h1 {
            text-align: center;
            color: #fff;
            margin-bottom: 10px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .subtitle {
            text-align: center;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 30px;
            font-style: italic;
        }
        
        .control-panel {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-group {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .control-group h3 {
            margin-top: 0;
            color: #fff;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 10px;
        }
        
        input, button, select {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }
        
        input[readonly] {
            background: rgba(200, 200, 200, 0.7);
            color: #555;
            cursor: not-allowed;
            border: 2px solid rgba(255, 255, 255, 0.5);
        }
        
        input[readonly]:focus {
            outline: 2px solid #FFD93D;
        }
        
        button {
            background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .blockchain-button {
            background: linear-gradient(45deg, #FFD93D, #6BCF7F);
        }
        
        .visualization {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .chart-container {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .chart-container h4 {
            margin-top: 0;
            color: #fff;
            text-align: center;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .metric-card {
            background: rgba(255, 255, 255, 0.15);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .metric-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #FFD93D;
            display: block;
        }
        
        .metric-label {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 5px;
        }
        
        .blockchain-metric {
            border: 2px solid #FFD93D;
        }
        
        .log-container {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            padding: 15px;
            height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .log-entry {
            margin-bottom: 5px;
            color: #00ff88;
        }
        
        .log-entry.error {
            color: #ff6b6b;
        }
        
        .log-entry.warning {
            color: #ffd93d;
        }
        
        .log-entry.blockchain {
            color: #FFD93D;
            font-weight: bold;
        }
        
        .status {
            text-align: center;
            font-weight: bold;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 20px;
        }
        
        .status.loading {
            background: rgba(255, 217, 61, 0.3);
            color: #FFD93D;
        }
        
        .status.ready {
            background: rgba(0, 255, 136, 0.3);
            color: #00ff88;
        }
        
        .status.error {
            background: rgba(255, 107, 107, 0.3);
            color: #ff6b6b;
        }
        
        .network-viz {
            width: 100%;
            height: 250px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.2);
        }
        
        @media (max-width: 768px) {
            .control-panel,
            .visualization {
                grid-template-columns: 1fr;
            }
            
            .metrics {
                grid-template-columns: 1fr;
            }
        }
        
        .log-p2p { color: #00BCD4; }
        .log-p2p::before { content: "üåê "; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß†‚õìÔ∏è Distributed Neural Network with Blockchain</h1>
        <p class="subtitle">Forward-Only Threshold-Gating Architecture with Smart Contracts & Incentives</p>
        
        <div id="status" class="status loading">
            üîÑ Loading WASM module...
        </div>
        
        <div class="control-panel">
            <div class="control-group">
                <h3>üîß Network Configuration</h3>
                <label>Device ID (auto-generated):</label>
                <input type="text" id="deviceId" placeholder="Loading device ID..." readonly>
                
                <label>Cluster ID:</label>
                <input type="text" id="clusterId" value="main_cluster" placeholder="Enter cluster ID">
                
                <label>Number of Nodes:</label>
                <input type="number" id="nodeCount" value="8" min="2" max="50">
                
                <button id="createCluster">üöÄ Create Cluster</button>
            </div>
            
            <div class="control-group">
                <h3>üìä Input & Training</h3>
                <label>Input Data (comma separated):</label>
                <input type="text" id="inputData" value="0.5, 0.3, 0.8, 0.2" placeholder="e.g., 0.1, 0.5, 0.9, 0.3">
                
                <label>Error Signal:</label>
                <input type="number" id="errorSignal" value="0.1" step="0.01" min="-1" max="1">
                
                <button id="processInput">‚ö° Process Input</button>
                <button id="updateError">üìâ Update Error</button>
                <button id="stepSimulation">üéØ Step Simulation</button>
            </div>

            <div class="control-group">
                <h3>‚õìÔ∏è Blockchain Operations</h3>
                <label>Node Owner (for borrowing):</label>
                <input type="text" id="nodeOwner" value="remote_device_001" placeholder="Node owner device ID">
                
                <label>Borrowing Duration (hours):</label>
                <input type="number" id="borrowDuration" value="2" min="0.5" max="24" step="0.5">
                
                <button id="borrowNode" class="blockchain-button">ü§ù Borrow Node</button>
                <button id="mineBlock" class="blockchain-button">‚õèÔ∏è Mine Block</button>
                <button id="validateChain" class="blockchain-button">‚úÖ Validate Chain</button>
            </div>

            <div class="control-section">
                <h3>üåê True Peer-to-Peer WebRTC Networking</h3>
                <div class="architecture-note" style="background: rgba(255, 215, 0, 0.1); border: 2px solid #ffd700; border-radius: 10px; padding: 15px; margin: 10px 0;">
                    <h4 style="color: #ffd700; margin-top: 0;">üîß True P2P Architecture:</h4>
                    <p style="margin: 5px 0;"><strong>‚úÖ Signaling Server:</strong> Used ONLY for initial discovery and WebRTC handshake</p>
                    <p style="margin: 5px 0;"><strong>‚úÖ Data Transfer:</strong> Direct peer-to-peer via WebRTC data channels</p>
                    <p style="margin: 5px 0;"><strong>‚úÖ No Relay:</strong> After handshake, ALL data flows directly between devices</p>
                    <p style="margin: 5px 0;"><strong>üîí Security:</strong> WebRTC provides built-in DTLS encryption</p>
                </div>
                <div class="control-row">
                    <input type="text" id="signalingServerUrl" placeholder="Loading signaling server..." style="width: 300px;">
                    <button id="configureSignaling" class="btn btn-primary">Configure Signaling Server</button>
                    <button id="getWebRTCStats" class="btn btn-secondary">Get WebRTC Stats</button>
                </div>
                <div class="control-row">
                    <button id="startDiscovery" class="btn btn-secondary">Start Peer Discovery</button>
                    <button id="autoConnectFreeNode" class="btn btn-accent">üéØ Auto-Connect to Free Node</button>
                    <button id="checkNodeAvailability" class="btn btn-secondary">Check Node Availability</button>
                    <button id="closeWebRTCConnection" class="btn btn-danger">Close Connection</button>
                </div>
                <div class="control-row">
                    <input type="text" id="messageText" placeholder="Message to send via WebRTC" value="Hello via direct P2P!" style="width: 300px;">
                    <button id="sendDirectMessage" class="btn btn-primary">Send Direct P2P Message</button>
                </div>
                <div class="control-row">
                    <input type="text" id="peerIdForRequest" placeholder="peer_device_id" style="width: 150px;">
                    <button id="requestNodeFromPeer" class="btn btn-accent">Request Node from Peer</button>
                    <button id="shareMemoryWithPeer" class="btn btn-accent">Share Memory Direct</button>
                </div>
                <div class="control-row">
                    <input type="text" id="collaborativePeers" placeholder="peer1,peer2,peer3" style="width: 200px;">
                    <input type="text" id="taskDescription" placeholder="Collaborative learning task" style="width: 200px;">
                    <button id="startCollabLearning" class="btn btn-primary">Start Collaborative Learning</button>
                </div>
                <div class="control-row">
                    <select id="errorUrgency">
                        <option value="1">Low Priority</option>
                        <option value="5" selected>Medium Priority</option>
                        <option value="9">High Priority</option>
                    </select>
                    <button id="propagateError" class="btn btn-warning">Propagate Error to Peers</button>
                    <button id="checkWebRTCConnections" class="btn btn-secondary">Check WebRTC Connections</button>
                </div>
                <div class="peer-list" style="background: rgba(255, 255, 255, 0.05); padding: 15px; border-radius: 5px; margin: 10px 0;">
                    <h4>üìã Discovered Peers:</h4>
                    <div id="discoveredPeers">No peers discovered yet</div>
                </div>
            </div>
        </div>
        
        <div class="metrics">
            <div class="metric-card">
                <span id="nodeCountMetric" class="metric-value">0</span>
                <div class="metric-label">Active Nodes</div>
            </div>
            <div class="metric-card">
                <span id="connectionCountMetric" class="metric-value">0</span>
                <div class="metric-label">Connections</div>
            </div>
            <div class="metric-card">
                <span id="avgSpecializationMetric" class="metric-value">0.00</span>
                <div class="metric-label">Avg Specialization</div>
            </div>
            <div class="metric-card">
                <span id="totalActivationsMetric" class="metric-value">0</span>
                <div class="metric-label">Total Activations</div>
            </div>
            <div class="metric-card blockchain-metric">
                <span id="accountBalanceMetric" class="metric-value">0.00</span>
                <div class="metric-label">üí∞ Account Credits</div>
            </div>
            <div class="metric-card blockchain-metric">
                <span id="totalBlocksMetric" class="metric-value">0</span>
                <div class="metric-label">‚õìÔ∏è Total Blocks</div>
            </div>
            <div class="metric-card blockchain-metric">
                <span id="memoryCapsulesMetric" class="metric-value">0</span>
                <div class="metric-label">üì¶ Memory Capsules</div>
            </div>
        </div>
        
        <div class="metrics-section">
            <h3>üìä P2P Network Stats</h3>
            <canvas id="p2pStatsChart" width="400" height="200"></canvas>
            <div id="p2pMetrics" class="metrics-display">
                <div>Connected Peers: <span id="connectedPeers">0</span></div>
                <div>Known Peers: <span id="knownPeers">0</span></div>
                <div>Pending Messages: <span id="pendingMessages">0</span></div>
                <div>Avg Latency: <span id="avgLatency">0ms</span></div>
                <div>Network Health: <span id="networkHealth">0%</span></div>
            </div>
        </div>
        
        <div class="visualization">
            <div class="chart-container">
                <h4>üìà Network Activity</h4>
                <canvas id="activityChart" class="network-viz"></canvas>
            </div>
            <div class="chart-container">
                <h4>üåê Network Topology</h4>
                <canvas id="topologyChart" class="network-viz"></canvas>
            </div>
            <div class="chart-container">
                <h4>‚õìÔ∏è Blockchain Stats</h4>
                <canvas id="blockchainChart" class="network-viz"></canvas>
            </div>
        </div>
        
        <div class="chart-container">
            <h4>üìù System Log</h4>
            <div id="logContainer" class="log-container"></div>
        </div>

        <div class="node-availability" style="background: rgba(255, 255, 255, 0.05); padding: 15px; border-radius: 5px; margin: 10px 0;">
            <h4>üîç Node Availability Status:</h4>
            <div id="nodeAvailabilityStats">
                <div>Total Peers: <span id="totalPeers">0</span></div>
                <div>Free Nodes: <span id="freeNodes" style="color: #4CAF50;">0</span></div>
                <div>Busy Nodes: <span id="busyNodes" style="color: #FF9800;">0</span></div>
                <div>Availability: <span id="availabilityRatio">0%</span></div>
            </div>
            <div id="currentConnection" style="margin-top: 10px;">
                <strong>Connected to:</strong> <span id="connectedPeer" style="color: #00BCD4;">None</span>
            </div>
        </div>
    </div>

    <script type="module">
        // Add cache busting to force reload of WASM module
        const cacheBuster = Date.now();
        const wasmModuleUrl = `./pkg/distributed_neural_network.js?v=${cacheBuster}`;
        
        import(wasmModuleUrl).then(module => {
            const { default: init, DistributedNeuralNetwork, P2PNetwork, WebRTCManager } = module;
            
            let network = null;
            let webrtcManager = null;
            let activityHistory = [];
            let errorHistory = [];
            let blockchainHistory = [];
            let currentDeviceId = null;
            let currentSignalingServer = null;
            
            // Generate or retrieve persistent device ID
            function initializeDeviceId() {
                const DEVICE_ID_KEY = 'dnn_device_id';
                let deviceId = localStorage.getItem(DEVICE_ID_KEY);
                
                if (!deviceId) {
                    // Generate random device ID with timestamp and random components
                    const timestamp = Date.now().toString(36);
                    const randomPart = Math.random().toString(36).substr(2, 8);
                    const deviceType = navigator.userAgent.includes('Mobile') ? 'mobile' : 'desktop';
                    deviceId = `${deviceType}_${timestamp}_${randomPart}`;
                    
                    localStorage.setItem(DEVICE_ID_KEY, deviceId);
                    addLog(`üÜî Generated new device ID: ${deviceId}`, 'info');
                } else {
                    addLog(`üÜî Retrieved existing device ID: ${deviceId}`, 'info');
                }
                
                currentDeviceId = deviceId;
                const deviceIdInput = document.getElementById('deviceId');
                deviceIdInput.value = deviceId;
                deviceIdInput.readOnly = true;
                deviceIdInput.title = 'Device ID is automatically generated and cannot be changed';
                
                return deviceId;
            }
            
            // Initialize persistent signaling server URL
            function initializeSignalingServer() {
                const SIGNALING_SERVER_KEY = 'dnn_signaling_server';
                let signalingUrl = localStorage.getItem(SIGNALING_SERVER_KEY);
                
                // Default signaling server URLs based on environment
                const defaultUrls = [
                    'ws://localhost:8080',
                    'wss://neural-signaling-server.herokuapp.com'
                ];
                
                if (!signalingUrl) {
                    // Try to detect if we're running locally or on GitHub Pages
                    const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                    signalingUrl = isLocal ? defaultUrls[0] : defaultUrls[1];
                    
                    localStorage.setItem(SIGNALING_SERVER_KEY, signalingUrl);
                    addLog(`üåê Set default signaling server: ${signalingUrl}`, 'info');
                } else {
                    addLog(`üåê Retrieved saved signaling server: ${signalingUrl}`, 'info');
                }
                
                currentSignalingServer = signalingUrl;
                const signalingInput = document.getElementById('signalingServerUrl');
                signalingInput.value = signalingUrl;
                signalingInput.title = 'Signaling server URL (editable, auto-saved)';
                
                return signalingUrl;
            }
            
            // Monitor and save signaling server URL changes
            function monitorSignalingServerChanges() {
                const signalingInput = document.getElementById('signalingServerUrl');
                
                // Save changes to localStorage when user modifies the URL
                signalingInput.addEventListener('input', (e) => {
                    const newUrl = e.target.value.trim();
                    if (newUrl !== currentSignalingServer) {
                        currentSignalingServer = newUrl;
                        localStorage.setItem('dnn_signaling_server', newUrl);
                        addLog(`üíæ Signaling server URL saved: ${newUrl}`, 'info');
                    }
                });
                
                // Also save on blur (when user clicks away)
                signalingInput.addEventListener('blur', (e) => {
                    const newUrl = e.target.value.trim();
                    if (newUrl && newUrl !== localStorage.getItem('dnn_signaling_server')) {
                        localStorage.setItem('dnn_signaling_server', newUrl);
                        addLog(`üíæ Signaling server URL updated: ${newUrl}`, 'info');
                    }
                });
            }
            
            // Monitor for device ID tampering attempts
            function monitorDeviceIdChanges() {
                const deviceIdInput = document.getElementById('deviceId');
                
                // Prevent any changes to the device ID
                deviceIdInput.addEventListener('input', (e) => {
                    if (e.target.value !== currentDeviceId) {
                        addLog('‚ö†Ô∏è Device ID cannot be changed! Resetting...', 'warning');
                        e.target.value = currentDeviceId;
                        
                        // Reset network if it exists
                        if (network) {
                            addLog('üîÑ Network reset due to device ID tampering attempt', 'warning');
                            network = null;
                            webrtcManager = null;
                            setStatus('üîÑ Network reset - create cluster again', 'loading');
                            
                            // Clear metrics
                            updateMetrics({ num_nodes: 0, num_connections: 0, avg_specialization: 0, total_activations: 0 });
                        }
                    }
                });
                
                // Also prevent paste events
                deviceIdInput.addEventListener('paste', (e) => {
                    e.preventDefault();
                    addLog('‚ö†Ô∏è Device ID cannot be changed!', 'warning');
                });
                
                // And keydown events
                deviceIdInput.addEventListener('keydown', (e) => {
                    // Allow only navigation keys, not editing
                    const allowedKeys = ['Tab', 'ArrowLeft', 'ArrowRight', 'Home', 'End'];
                    if (!allowedKeys.includes(e.key)) {
                        e.preventDefault();
                    }
                });
            }
            
            // Send regular heartbeat with current node status
            function sendHeartbeatWithStatus() {
                if (!network || !network.is_connected_to_signaling_server()) {
                    return;
                }
                
                try {
                    // Calculate current node status based on activity
                    const currentTime = Date.now();
                    const isProcessing = false; // For demo, always start as not processing
                    const activeQueries = 0; // No active queries initially
                    const processingLoad = Math.random() * 0.2; // Low random load (0-20%)
                    const cpuUsage = 0.1 + Math.random() * 0.3; // 10-40% CPU
                    const memoryUsage = 0.2 + Math.random() * 0.3; // 20-50% memory
                    const availableNodes = 8; // Number of available neural nodes
                    
                    // Send heartbeat via the network's built-in method
                    const success = network.send_heartbeat();
                    if (success) {
                        addLog('üíì Sent heartbeat with updated node status (Load: ' + (processingLoad * 100).toFixed(1) + '%)', 'p2p');
                    } else {
                        addLog('‚ö†Ô∏è Failed to send heartbeat - not connected to signaling server', 'warning');
                    }
                    
                } catch (error) {
                    console.warn('Failed to send heartbeat:', error);
                }
            }
            
            // Start heartbeat timer
            function startHeartbeatTimer() {
                // Send heartbeat every 15 seconds
                setInterval(sendHeartbeatWithStatus, 15000);
                
                // Send initial heartbeat after network creation
                setTimeout(sendHeartbeatWithStatus, 3000);
            }
            
            // Status management
            function setStatus(message, type = 'loading') {
                const statusEl = document.getElementById('status');
                statusEl.textContent = message;
                statusEl.className = `status ${type}`;
            }
            
            // Logging
            function addLog(message, type = 'info') {
                const logContainer = document.getElementById('logContainer');
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry log-${type}`;
                logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                logContainer.appendChild(logEntry);
                logContainer.scrollTop = logContainer.scrollHeight;
                
                // Keep only last 100 messages
                while (logContainer.children.length > 100) {
                    logContainer.removeChild(logContainer.firstChild);
                }
            }
            
            // Update metrics display
            function updateMetrics(state) {
                document.getElementById('nodeCountMetric').textContent = state.num_nodes;
                document.getElementById('connectionCountMetric').textContent = state.num_connections;
                document.getElementById('avgSpecializationMetric').textContent = state.avg_specialization.toFixed(3);
                document.getElementById('totalActivationsMetric').textContent = state.total_activations;
                
                // Update blockchain metrics
                if (network) {
                    const balance = network.get_account_balance();
                    document.getElementById('accountBalanceMetric').textContent = balance.toFixed(2);
                    
                    const blockchainStats = network.get_blockchain_stats();
                    if (blockchainStats) {
                        document.getElementById('totalBlocksMetric').textContent = blockchainStats.total_blocks;
                        document.getElementById('memoryCapsulesMetric').textContent = blockchainStats.total_memory_capsules;
                    }
                }
            }
            
            // Visualization functions
            function drawActivityChart() {
                const canvas = document.getElementById('activityChart');
                const ctx = canvas.getContext('2d');
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                if (activityHistory.length < 2) return;
                
                ctx.strokeStyle = '#00ff88';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                const maxVal = Math.max(...activityHistory);
                const minVal = Math.min(...activityHistory);
                const range = maxVal - minVal || 1;
                
                for (let i = 0; i < activityHistory.length; i++) {
                    const x = (i / (activityHistory.length - 1)) * canvas.width;
                    const y = canvas.height - ((activityHistory[i] - minVal) / range) * canvas.height;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.stroke();
                
                // Draw error history
                if (errorHistory.length > 1) {
                    ctx.strokeStyle = '#ff6b6b';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    
                    const maxError = Math.max(...errorHistory);
                    const minError = Math.min(...errorHistory);
                    const errorRange = maxError - minError || 1;
                    
                    for (let i = 0; i < errorHistory.length; i++) {
                        const x = (i / (errorHistory.length - 1)) * canvas.width;
                        const y = canvas.height - ((errorHistory[i] - minError) / errorRange) * canvas.height;
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    
                    ctx.stroke();
                }
            }
            
            function drawTopologyChart(nodeCount, connectionCount) {
                const canvas = document.getElementById('topologyChart');
                const ctx = canvas.getContext('2d');
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                if (nodeCount === 0) return;
                
                // Draw nodes in a circle
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = Math.min(canvas.width, canvas.height) / 3;
                
                const nodes = [];
                for (let i = 0; i < nodeCount; i++) {
                    const angle = (i / nodeCount) * 2 * Math.PI;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    nodes.push({ x, y });
                }
                
                // Draw connections (simplified)
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                const connectionsPerNode = Math.min(3, Math.floor(connectionCount / nodeCount));
                
                for (let i = 0; i < nodeCount; i++) {
                    for (let j = 1; j <= connectionsPerNode; j++) {
                        const targetIndex = (i + j) % nodeCount;
                        ctx.beginPath();
                        ctx.moveTo(nodes[i].x, nodes[i].y);
                        ctx.lineTo(nodes[targetIndex].x, nodes[targetIndex].y);
                        ctx.stroke();
                    }
                }
                
                // Draw nodes
                ctx.fillStyle = '#FFD93D';
                for (const node of nodes) {
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, 6, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }

            function drawBlockchainChart() {
                const canvas = document.getElementById('blockchainChart');
                const ctx = canvas.getContext('2d');
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                if (!network) return;
                
                const stats = network.get_blockchain_stats();
                if (!stats) return;
                
                // Draw simple blockchain visualization
                const blockWidth = 40;
                const blockHeight = 30;
                const blockSpacing = 10;
                const startX = 20;
                const startY = canvas.height / 2;
                
                ctx.fillStyle = '#FFD93D';
                ctx.strokeStyle = '#FFF';
                ctx.lineWidth = 2;
                
                for (let i = 0; i < Math.min(stats.total_blocks, 10); i++) {
                    const x = startX + i * (blockWidth + blockSpacing);
                    const y = startY - blockHeight / 2;
                    
                    // Draw block
                    ctx.fillRect(x, y, blockWidth, blockHeight);
                    ctx.strokeRect(x, y, blockWidth, blockHeight);
                    
                    // Draw block number
                    ctx.fillStyle = '#000';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(i.toString(), x + blockWidth/2, y + blockHeight/2 + 4);
                    ctx.fillStyle = '#FFD93D';
                    
                    // Draw connection to next block
                    if (i < Math.min(stats.total_blocks - 1, 9)) {
                        ctx.beginPath();
                        ctx.moveTo(x + blockWidth, y + blockHeight/2);
                        ctx.lineTo(x + blockWidth + blockSpacing, y + blockHeight/2);
                        ctx.stroke();
                    }
                }
                
                // Draw stats text
                ctx.fillStyle = '#FFF';
                ctx.font = '14px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`Blocks: ${stats.total_blocks}`, 20, 30);
                ctx.fillText(`Transactions: ${stats.total_transactions}`, 20, 50);
                ctx.fillText(`Memory Capsules: ${stats.total_memory_capsules}`, 20, 70);
                ctx.fillText(`Accounts: ${stats.total_accounts}`, 20, 90);
            }
            
            function drawP2PStatsChart(stats) {
                const canvas = document.getElementById('p2pStatsChart');
                const ctx = canvas.getContext('2d');
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Background
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Network health visualization
                const healthPercent = (stats.network_health || 0) * 100;
                const healthColor = healthPercent > 70 ? '#4CAF50' : healthPercent > 40 ? '#FF9800' : '#F44336';
                
                // Health bar
                ctx.fillStyle = healthColor;
                ctx.fillRect(20, 20, (canvas.width - 40) * (healthPercent / 100), 30);
                
                // Health border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(20, 20, canvas.width - 40, 30);
                
                // Health label
                ctx.fillStyle = '#fff';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`Network Health: ${Math.round(healthPercent)}%`, canvas.width / 2, 40);
                
                // Connection stats
                const connectedPeers = stats.connected_peers || 0;
                const knownPeers = stats.known_peers || 0;
                
                // Peer connection visualization
                ctx.fillStyle = '#00BCD4';
                ctx.fillRect(20, 70, Math.min(connectedPeers * 30, canvas.width - 40), 20);
                
                ctx.fillStyle = 'rgba(156, 39, 176, 0.5)';
                ctx.fillRect(20, 100, Math.min(knownPeers * 20, canvas.width - 40), 20);
                
                // Labels
                ctx.fillStyle = '#fff';
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`Connected: ${connectedPeers}`, 25, 85);
                ctx.fillText(`Known: ${knownPeers}`, 25, 115);
                
                // Latency indicator
                const avgLatency = stats.average_latency || 0;
                const latencyColor = avgLatency < 100 ? '#4CAF50' : avgLatency < 300 ? '#FF9800' : '#F44336';
                
                ctx.fillStyle = latencyColor;
                ctx.fillRect(20, 140, Math.min(avgLatency / 2, canvas.width - 40), 15);
                
                ctx.fillStyle = '#fff';
                ctx.fillText(`Avg Latency: ${Math.round(avgLatency)}ms`, 25, 152);
            }
            
            // Event handlers
            document.getElementById('createCluster').addEventListener('click', () => {
                const deviceId = currentDeviceId; // Use the persistent device ID
                const clusterId = document.getElementById('clusterId').value;
                const nodeCount = parseInt(document.getElementById('nodeCount').value);
                
                if (!deviceId) {
                    addLog('‚ùå Device ID not initialized!', 'error');
                    return;
                }
                
                if (!network) {
                    network = new DistributedNeuralNetwork(deviceId);
                    webrtcManager = new WebRTCManager(deviceId);
                    addLog(`Created network for device: ${deviceId}`, 'blockchain');
                    addLog(`Initialized WebRTC manager for device: ${deviceId}`, 'p2p');
                    
                    // Start heartbeat timer for regular status updates
                    startHeartbeatTimer();
                    
                    // Auto-configure signaling server
                    const signalingUrl = document.getElementById('signalingServerUrl').value.trim() || currentSignalingServer;
                    if (signalingUrl) {
                        const configSuccess = network.configure_signaling_server(signalingUrl);
                        if (configSuccess) {
                            addLog(`üåê Auto-configured signaling server: ${signalingUrl}`, 'p2p');
                            
                            // Auto-start peer discovery after a short delay
                            setTimeout(() => {
                                if (network.is_connected_to_signaling_server()) {
                                    const discoverySuccess = network.start_peer_discovery();
                                    if (discoverySuccess) {
                                        addLog('üîç Auto-started peer discovery after network creation', 'p2p');
                                        setupDiscoveryPolling();
                                    } else {
                                        addLog('‚ö†Ô∏è Auto-discovery failed, use manual discovery button', 'warning');
                                    }
                                } else {
                                    addLog('‚ö†Ô∏è Not connected to signaling server yet, use manual discovery', 'warning');
                                }
                            }, 2000); // Wait 2 seconds for WebSocket connection
                        } else {
                            addLog('‚ùå Failed to configure signaling server', 'error');
                        }
                    }
                }
                
                const success = network.create_cluster(clusterId, nodeCount);
                if (success) {
                    addLog(`Created cluster '${clusterId}' with ${nodeCount} nodes`);
                    setStatus('üü¢ Network ready', 'ready');
                    
                    // Update visualization
                    const state = network.get_cluster_state(clusterId);
                    if (state) {
                        updateMetrics(state);
                        drawTopologyChart(nodeCount, state.num_connections);
                        drawBlockchainChart();
                    }
                } else {
                    addLog('Failed to create cluster', 'error');
                }
            });
            
            document.getElementById('processInput').addEventListener('click', () => {
                if (!network) {
                    addLog('Create a network first!', 'error');
                    return;
                }
                
                const clusterId = document.getElementById('clusterId').value;
                const inputStr = document.getElementById('inputData').value;
                const inputData = inputStr.split(',').map(x => parseFloat(x.trim()));
                
                const outputs = network.process_input(clusterId, inputData);
                const avgOutput = outputs.reduce((sum, val) => sum + val, 0) / outputs.length;
                
                activityHistory.push(avgOutput);
                if (activityHistory.length > 100) {
                    activityHistory.shift();
                }
                
                addLog(`Processed input: [${inputData.join(', ')}] ‚Üí avg output: ${avgOutput.toFixed(4)}`);
                
                // Update metrics
                const state = network.get_cluster_state(clusterId);
                if (state) {
                    updateMetrics(state);
                    drawTopologyChart(state.num_nodes, state.num_connections);
                }
                
                drawActivityChart();
                drawBlockchainChart();
            });
            
            document.getElementById('updateError').addEventListener('click', () => {
                if (!network) {
                    addLog('Create a network first!', 'error');
                    return;
                }
                
                const clusterId = document.getElementById('clusterId').value;
                const error = parseFloat(document.getElementById('errorSignal').value);
                
                network.update_error_signal(clusterId, error);
                
                errorHistory.push(Math.abs(error));
                if (errorHistory.length > 100) {
                    errorHistory.shift();
                }
                
                addLog(`Updated error signal: ${error}`);
                drawActivityChart();
            });
            
            document.getElementById('stepSimulation').addEventListener('click', () => {
                if (!network) {
                    addLog('Create a network first!', 'error');
                    return;
                }
                
                network.step_simulation(1.0);
                addLog('Stepped simulation forward');
                
                // Update metrics
                const clusterId = document.getElementById('clusterId').value;
                const state = network.get_cluster_state(clusterId);
                if (state) {
                    updateMetrics(state);
                }
            });

            document.getElementById('borrowNode').addEventListener('click', () => {
                if (!network) {
                    addLog('Create a network first!', 'error');
                    return;
                }
                
                const nodeOwner = document.getElementById('nodeOwner').value;
                const duration = parseFloat(document.getElementById('borrowDuration').value);
                const nodeId = 'remote_node_001';
                
                const borrowingId = network.request_node_borrowing(nodeOwner, nodeId, duration);
                if (borrowingId) {
                    addLog(`‚úÖ Node borrowing approved: ${borrowingId}`, 'blockchain');
                    updateMetrics({ num_nodes: 0, num_connections: 0, avg_specialization: 0, total_activations: 0 });
                } else {
                    addLog('‚ùå Node borrowing request denied', 'error');
                }
            });

            document.getElementById('mineBlock').addEventListener('click', () => {
                if (!network) {
                    addLog('Create a network first!', 'error');
                    return;
                }
                
                const blockHash = network.mine_block();
                if (blockHash) {
                    addLog(`‚õèÔ∏è Mined new block: ${blockHash}`, 'blockchain');
                    drawBlockchainChart();
                    updateMetrics({ num_nodes: 0, num_connections: 0, avg_specialization: 0, total_activations: 0 });
                } else {
                    addLog('No pending transactions to mine', 'warning');
                }
            });

            document.getElementById('validateChain').addEventListener('click', () => {
                if (!network) {
                    addLog('Create a network first!', 'error');
                    return;
                }
                
                const isValid = network.validate_blockchain();
                if (isValid) {
                    addLog('‚úÖ Blockchain validation passed', 'blockchain');
                } else {
                    addLog('‚ùå Blockchain validation failed!', 'error');
                }
            });
            
            // P2P Networking event handlers
            document.getElementById('configureSignaling').addEventListener('click', () => {
                const signalingUrl = document.getElementById('signalingServerUrl').value.trim() || currentSignalingServer;
                if (network && signalingUrl) {
                    try {
                        const success = network.configure_signaling_server(signalingUrl);
                        if (success) {
                            addLog(`üåê Configured signaling server: ${signalingUrl}`, 'p2p');
                            setStatus('üü¢ Signaling server configured', 'ready');
                            
                            // Save the URL if it's different
                            if (signalingUrl !== currentSignalingServer) {
                                currentSignalingServer = signalingUrl;
                                localStorage.setItem('dnn_signaling_server', signalingUrl);
                                addLog(`üíæ Signaling server URL saved: ${signalingUrl}`, 'info');
                            }
                        } else {
                            addLog('‚ùå Failed to configure signaling server', 'error');
                        }
                    } catch (e) {
                        addLog(`‚ùå Error configuring signaling server: ${e.message}`, 'error');
                    }
                } else if (!signalingUrl) {
                    addLog('‚ùå Please enter a signaling server URL', 'error');
                } else {
                    addLog('‚ùå Create a network first!', 'error');
                }
            });

            document.getElementById('startDiscovery').addEventListener('click', () => {
                if (network) {
                    // Configure signaling server before starting discovery if not already configured
                    const signalingUrl = document.getElementById('signalingServerUrl').value.trim() || currentSignalingServer;
                    if (signalingUrl) {
                        const configSuccess = network.configure_signaling_server(signalingUrl);
                        if (configSuccess) {
                            addLog(`üåê Connected to signaling server: ${signalingUrl}`, 'p2p');
                            
                            // Wait for connection to establish, then start discovery
                            setTimeout(() => {
                                if (network.is_connected_to_signaling_server()) {
                                    const success = network.start_peer_discovery();
                                    if (success) {
                                        addLog('üîç Started real peer discovery protocol', 'p2p');
                                        setStatus('üåê Discovering real peers', 'connecting');
                                        
                                        // Set up discovery result polling
                                        setupDiscoveryPolling();
                                    } else {
                                        addLog('‚ùå Failed to start peer discovery', 'error');
                                    }
                                } else {
                                    addLog('‚ùå Not connected to signaling server', 'error');
                                }
                            }, 1000); // Wait 1 second for WebSocket connection
                        } else {
                            addLog('‚ùå Failed to connect to signaling server', 'error');
                        }
                    } else {
                        addLog('‚ùå No signaling server configured', 'error');
                        return;
                    }
                } else {
                    addLog('‚ùå Create a network first!', 'error');
                }
            });

            // Set up polling for discovery results
            function setupDiscoveryPolling() {
                let pollCount = 0;
                const maxPolls = 20; // Poll for 10 seconds (increased from 5)
                
                addLog('üîÑ Starting discovery polling...', 'p2p');
                
                const pollInterval = setInterval(() => {
                    pollCount++;
                    
                    if (!network) {
                        clearInterval(pollInterval);
                        return;
                    }
                    
                    const peersJson = network.get_discovered_peers();
                    let peers = [];
                    
                    try {
                        peers = JSON.parse(peersJson);
                    } catch (e) {
                        console.warn('Failed to parse peers JSON:', e);
                    }
                    
                    addLog(`üîç Discovery poll ${pollCount}: Found ${peers.length} peers`, 'p2p');
                    
                    if (peers.length > 0) {
                        clearInterval(pollInterval);
                        addLog(`üéâ Discovery complete! Found ${peers.length} real peers from signaling server!`, 'p2p');
                        
                        // Process the discovered peers to update node registry
                        const processSuccess = network.handle_discovery_results(JSON.stringify(peers));
                        if (processSuccess) {
                            addLog(`‚úÖ Processed ${peers.length} peer records into local registry`, 'p2p');
                        } else {
                            addLog(`‚ö†Ô∏è Failed to process peer discovery results`, 'warning');
                        }
                        
                        // Update the peer display
                        updateDiscoveredPeers(peers);
                        
                        // Now check for free nodes among discovered peers
                        addLog('üîç Analyzing which discovered peers are available for processing...', 'p2p');
                        
                        setTimeout(() => {
                            try {
                                if (typeof network.find_free_nodes === 'function') {
                                    const freeNodesJson = network.find_free_nodes();
                                    const freeNodes = JSON.parse(freeNodesJson);
                                    addLog(`üéØ Analysis complete: ${freeNodes.length} free nodes available`, 'p2p');
                                    
                                    updateNodeAvailabilityStats();
                                    
                                    if (freeNodes.length > 0) {
                                        addLog('üí° Ready for auto-connection! Use "Auto-Connect to Free Node" button', 'info');
                                    } else {
                                        addLog('‚ö†Ô∏è All discovered peers are currently busy processing', 'warning');
                                    }
                                } else {
                                    addLog('‚ö†Ô∏è Free node detection not available, using basic peer connection', 'warning');
                                    updateNodeAvailabilityStats();
                                }
                            } catch (error) {
                                addLog(`‚ùå Free node analysis failed: ${error.message}`, 'error');
                            }
                        }, 1000); // Brief delay to allow node status processing
                        
                    } else if (pollCount >= maxPolls) {
                        clearInterval(pollInterval);
                        addLog(`‚è∞ Discovery timeout after ${maxPolls/2} seconds. No real peers found.`, 'warning');
                        addLog('üí° Try: 1) Open another browser tab/window, 2) Check signaling server URL', 'info');
                        setStatus('üü° No peers found', 'ready');
                    }
                }, 500); // Poll every 500ms
            }

            function updateDiscoveredPeers(peers) {
                const peerContainer = document.getElementById('discoveredPeers');
                if (peers.length === 0) {
                    peerContainer.innerHTML = 'No peers discovered yet';
                    return;
                }
                
                peerContainer.innerHTML = peers.map(peer => {
                    const bgColor = 'rgba(255, 255, 255, 0.1)';
                    const borderColor = 'transparent';
                    const selectedLabel = '';
                    
                    return `
                        <div style="background: ${bgColor}; border: 2px solid ${borderColor}; padding: 10px; margin: 5px 0; border-radius: 5px; display: flex; justify-content: space-between; align-items: center;">
                            <span><strong>${peer.device_id}</strong>${selectedLabel}<br>
                                  <small style="color: rgba(255,255,255,0.7);">Capabilities: ${peer.capabilities.join(', ')}</small><br>
                                  <small style="color: rgba(255,255,255,0.6);">Specializations: ${peer.cluster_specializations ? peer.cluster_specializations.join(', ') : 'None'}</small>
                            </span>
                            <button onclick="connectToPeer('${peer.device_id}')" style="padding: 5px 10px; background: #9C27B0; color: white; border: none; border-radius: 3px; cursor: pointer;">
                                Connect
                            </button>
                        </div>
                    `;
                }).join('');
            }

            window.connectToPeer = function(peerId) {
                if (webrtcManager) {
                    addLog(`üîó Initiating WebRTC connection to: ${peerId}`, 'p2p');
                    // This would trigger the WebRTC connection process
                    document.getElementById('autoConnectFreeNode').click();
                }
            };

            document.getElementById('autoConnectFreeNode').addEventListener('click', async () => {
                if (!network) {
                    addLog('‚ùå Create a network first!', 'error');
                    return;
                }
                
                addLog('üéØ Searching for free nodes...', 'p2p');
                setStatus('üîç Finding free nodes', 'connecting');
                
                try {
                    if (typeof network.auto_connect_to_free_node === 'function') {
                        const connectedPeerId = await network.auto_connect_to_free_node();
                        if (connectedPeerId) {
                            addLog(`‚úÖ Auto-connected to free node: ${connectedPeerId}`, 'p2p');
                            setStatus('üü¢ Connected to free node', 'ready');
                            document.getElementById('connectedPeer').textContent = connectedPeerId;
                            
                            // Update node availability stats
                            updateNodeAvailabilityStats();
                        } else {
                            addLog('‚ùå No free nodes available for connection', 'warning');
                            setStatus('üü° No free nodes found', 'ready');
                        }
                    } else {
                        // Fallback: connect to any discovered peer
                        addLog('‚ö†Ô∏è Free node detection not available, using fallback connection', 'warning');
                        const peersJson = network.get_discovered_peers();
                        const peers = JSON.parse(peersJson);
                        
                        if (peers.length > 0) {
                            const randomIndex = Math.floor(Math.random() * peers.length);
                            const selectedPeer = peers[randomIndex];
                            
                            addLog(`üéØ Fallback: connecting to random peer: ${selectedPeer.device_id}`, 'p2p');
                            const success = await network.initiate_webrtc_connection(selectedPeer.device_id);
                            if (success) {
                                addLog(`‚úÖ Connected to peer: ${selectedPeer.device_id}`, 'p2p');
                                setStatus('üü¢ Connected to peer', 'ready');
                                document.getElementById('connectedPeer').textContent = selectedPeer.device_id;
                            } else {
                                addLog(`‚ùå Failed to connect to peer: ${selectedPeer.device_id}`, 'error');
                                setStatus('‚ùå Connection failed', 'error');
                            }
                        } else {
                            addLog('‚ùå No peers available for connection', 'warning');
                            setStatus('üü° No peers found', 'ready');
                        }
                    }
                } catch (error) {
                    addLog(`‚ùå Failed to auto-connect: ${error.message}`, 'error');
                    addLog('üí° Try rebuilding WASM module with "./build.sh"', 'info');
                    setStatus('‚ùå Auto-connection failed', 'error');
                }
            });

            document.getElementById('checkNodeAvailability').addEventListener('click', () => {
                if (!network) {
                    addLog('‚ùå Create a network first!', 'error');
                    return;
                }
                
                addLog('üìä Checking node availability...', 'info');
                updateNodeAvailabilityStats();
                
                try {
                    const freeNodesJson = network.find_free_nodes();
                    const freeNodes = JSON.parse(freeNodesJson);
                    addLog(`üîç Found ${freeNodes.length} free nodes available for processing`, 'p2p');
                    
                    freeNodes.forEach(node => {
                        addLog(`üü¢ Free node: ${node.device_id} - Load: ${(node.node_status.processing_load * 100).toFixed(1)}%, Available nodes: ${node.available_nodes}`, 'info');
                    });
                    
                    if (freeNodes.length === 0) {
                        addLog('‚ö†Ô∏è No free nodes currently available. All peers are busy.', 'warning');
                    }
                } catch (e) {
                    addLog('‚ùå Free node detection not available yet. Please rebuild WASM module.', 'error');
                    addLog('üí° Run "./build.sh" to rebuild with latest features.', 'info');
                }
            });

            function updateNodeAvailabilityStats() {
                if (!network) return;
                
                try {
                    if (typeof network.get_node_availability_stats === 'function') {
                        const statsJson = network.get_node_availability_stats();
                        const stats = JSON.parse(statsJson);
                        
                        document.getElementById('totalPeers').textContent = stats.total_peers || 0;
                        document.getElementById('freeNodes').textContent = stats.free_nodes || 0;
                        document.getElementById('busyNodes').textContent = stats.busy_nodes || 0;
                        document.getElementById('availabilityRatio').textContent = 
                            `${Math.round((stats.availability_ratio || 0) * 100)}%`;
                        
                        // Update color based on availability
                        const availabilityElement = document.getElementById('availabilityRatio');
                        const ratio = stats.availability_ratio || 0;
                        if (ratio > 0.7) {
                            availabilityElement.style.color = '#4CAF50'; // Green
                        } else if (ratio > 0.3) {
                            availabilityElement.style.color = '#FF9800'; // Orange
                        } else {
                            availabilityElement.style.color = '#F44336'; // Red
                        }
                    } else {
                        // Fallback: use basic peer count
                        const peersJson = network.get_discovered_peers();
                        const peers = JSON.parse(peersJson);
                        document.getElementById('totalPeers').textContent = peers.length;
                        document.getElementById('freeNodes').textContent = '?';
                        document.getElementById('busyNodes').textContent = '?';
                        document.getElementById('availabilityRatio').textContent = 'N/A';
                    }
                } catch (e) {
                    console.warn('Failed to update node availability stats:', e);
                    // Set fallback values
                    document.getElementById('totalPeers').textContent = '0';
                    document.getElementById('freeNodes').textContent = '?';
                    document.getElementById('busyNodes').textContent = '?';
                    document.getElementById('availabilityRatio').textContent = 'N/A';
                }
            }

            document.getElementById('sendDirectMessage').addEventListener('click', () => {
                const message = document.getElementById('messageText').value;
                const connectedPeerElement = document.getElementById('connectedPeer');
                const peerId = connectedPeerElement ? connectedPeerElement.textContent : '';
                
                if (network && message && peerId && peerId !== 'None') {
                    try {
                        network.send_direct_message(message);
                        addLog(`üì§ Sent direct P2P message to ${peerId}: ${message}`, 'p2p');
                    } catch (error) {
                        addLog(`‚ùå Failed to send direct message: ${error}`, 'error');
                    }
                } else {
                    addLog('‚ùå No active peer connection or missing message', 'error');
                }
            });

            document.getElementById('requestNodeFromPeer').addEventListener('click', () => {
                const peerId = document.getElementById('peerIdForRequest').value;
                if (network && peerId) {
                    const requestId = network.request_node_from_peer(peerId, 'inference', 30);
                    if (requestId) {
                        addLog(`üì§ Requested node from peer ${peerId}, request ID: ${requestId}`, 'p2p');
                    } else {
                        addLog(`‚ùå Failed to request node from peer: ${peerId}`, 'error');
                    }
                }
            });

            document.getElementById('shareMemoryWithPeer').addEventListener('click', () => {
                const peerId = document.getElementById('peerIdForRequest').value;
                const clusterId = document.getElementById('clusterId').value;
                if (network && peerId && clusterId) {
                    const success = network.share_memory_with_peer(peerId, clusterId);
                    if (success) {
                        addLog(`üíæ Shared memory capsule with peer: ${peerId}`, 'p2p');
                    } else {
                        addLog(`‚ùå Failed to share memory with peer: ${peerId}`, 'error');
                    }
                }
            });

            document.getElementById('startCollabLearning').addEventListener('click', () => {
                const peerList = document.getElementById('collaborativePeers').value;
                const taskDesc = document.getElementById('taskDescription').value;
                if (network && peerList && taskDesc) {
                    const peerIds = peerList.split(',').map(p => p.trim());
                    const sessionId = network.start_collaborative_learning(peerIds, taskDesc);
                    if (sessionId) {
                        addLog(`üéØ Started collaborative learning session: ${sessionId}`, 'p2p');
                        addLog(`üìö Task: ${taskDesc}`, 'training');
                        addLog(`üë• Participants: ${peerIds.length}`, 'training');
                    } else {
                        addLog('‚ùå Failed to start collaborative learning', 'error');
                    }
                }
            });

            document.getElementById('propagateError').addEventListener('click', () => {
                const clusterId = document.getElementById('clusterId').value;
                const urgency = parseInt(document.getElementById('errorUrgency').value);
                if (network && clusterId) {
                    const propagatedCount = network.propagate_error_to_peers(clusterId, urgency);
                    addLog(`üì° Error propagated to ${propagatedCount} peers (urgency: ${urgency})`, 'p2p');
                }
            });

            document.getElementById('checkWebRTCConnections').addEventListener('click', () => {
                const connectedPeerElement = document.getElementById('connectedPeer');
                const peerId = connectedPeerElement ? connectedPeerElement.textContent : '';
                
                if (network && peerId && peerId !== 'None') {
                    const connected = network.check_webrtc_connections();
                    addLog(`üîó Connection to ${peerId}: ${connected ? 'CONNECTED ‚úÖ' : 'NOT CONNECTED ‚ùå'}`, 
                           connected ? 'p2p' : 'error');
                } else {
                    addLog('‚ùå No active peer connection to check', 'error');
                }
            });

            document.getElementById('getWebRTCStats').addEventListener('click', () => {
                if (webrtcManager) {
                    try {
                        const stats = JSON.parse(webrtcManager.get_connection_stats());
                        addLog(`üìä WebRTC Stats: ${JSON.stringify(stats, null, 2)}`, 'p2p');
                    } catch (error) {
                        addLog(`‚ùå Failed to get WebRTC stats: ${error}`, 'error');
                    }
                } else {
                    addLog('‚ùå Create a network first!', 'error');
                }
            });

            // Auto-update P2P network visualization
            function updateP2PNetworkStats() {
                if (!network) return;

                try {
                    const stats = network.get_p2p_network_stats();
                    if (stats) {
                        document.getElementById('connectedPeers').textContent = stats.connected_peers || 0;
                        document.getElementById('knownPeers').textContent = stats.known_peers || 0;
                        document.getElementById('pendingMessages').textContent = stats.pending_messages || 0;
                        document.getElementById('avgLatency').textContent = `${Math.round(stats.average_latency || 0)}ms`;
                        document.getElementById('networkHealth').textContent = `${Math.round((stats.network_health || 0) * 100)}%`;
                        
                        drawP2PStatsChart(stats);
                    }
                    
                    // Check for successful auto-connections
                    const connectedPeerElement = document.getElementById('connectedPeer');
                    const connectedPeerId = connectedPeerElement ? connectedPeerElement.textContent : '';
                    
                    if (connectedPeerId && connectedPeerId !== 'None' && network.check_webrtc_connections()) {
                        const isConnected = network.is_peer_connected_webrtc(connectedPeerId);
                        if (isConnected) {
                            // Update status if we successfully connected
                            const currentStatus = document.getElementById('status').textContent;
                            if (currentStatus.includes('connecting')) {
                                setStatus('üü¢ WebRTC connected to peer', 'ready');
                                addLog(`‚úÖ Successfully connected to auto-selected peer: ${connectedPeerId}`, 'p2p');
                                
                                // Update the peer list to show connection status
                                updateDiscoveredPeers(JSON.parse(network.get_discovered_peers()));
                            }
                        }
                    }
                } catch (e) {
                    console.warn('Failed to update P2P stats:', e);
                }
            }
            
            // Monitor auto-connection progress
            function monitorAutoConnection() {
                const connectedPeerElement = document.getElementById('connectedPeer');
                const connectedPeerId = connectedPeerElement ? connectedPeerElement.textContent : '';
                
                if (connectedPeerId && connectedPeerId !== 'None' && network) {
                    const isConnected = network.is_peer_connected_webrtc(connectedPeerId);
                    if (isConnected) {
                        addLog(`üîó Auto-connection established with: ${connectedPeerId}`, 'p2p');
                        
                        // Try sending a test message
                        setTimeout(() => {
                            try {
                                network.send_direct_message("Hello from auto-connected peer!");
                                addLog(`üì§ Sent test message to auto-connected peer: ${connectedPeerId}`, 'p2p');
                            } catch (e) {
                                addLog(`‚ö†Ô∏è Could not send test message: ${e.message}`, 'warning');
                            }
                        }, 2000);
                        
                        return true; // Connection established
                    }
                }
                return false; // Still connecting or no target
            }
            
            // Initialize WASM module
            async function initializeDemo() {
                try {
                    // Initialize device ID first
                    initializeDeviceId();
                    monitorDeviceIdChanges();
                    
                    // Initialize signaling server URL
                    initializeSignalingServer();
                    monitorSignalingServerChanges();
                    
                    await init();
                    setStatus('üü¢ WASM module loaded successfully', 'ready');
                    addLog('Distributed Neural Network with Blockchain WASM module initialized');
                    addLog('Ready to create networks and process data');
                    addLog(`üîí Device ID locked: ${currentDeviceId}`, 'info');
                    addLog(`üåê Signaling server ready: ${currentSignalingServer}`, 'info');
                    
                    // Check if new features are available
                    if (network && typeof network.find_free_nodes === 'function') {
                        addLog('‚úÖ Advanced free node detection available', 'info');
                    } else {
                        addLog('‚ö†Ô∏è Using fallback mode - rebuild WASM for advanced features', 'warning');
                        addLog('üí° Run "./build.sh" to enable free node detection', 'info');
                    }
                    
                    // Enable controls
                    document.querySelectorAll('button').forEach(btn => btn.disabled = false);
                    
                } catch (error) {
                    setStatus('‚ùå Failed to load WASM module', 'error');
                    addLog(`Error: ${error.message}`, 'error');
                    console.error(error);
                }
            }
            
            // Start demo
            initializeDemo();
            
            // Auto-run demo after 2 seconds if user hasn't interacted
            setTimeout(() => {
                if (!network) {
                    document.getElementById('createCluster').click();
                    setTimeout(() => {
                        document.getElementById('processInput').click();
                    }, 1000);
                }
            }, 2000);

            // Auto-update blockchain chart periodically
            setInterval(() => {
                if (network) {
                    drawBlockchainChart();
                    updateMetrics({ num_nodes: 0, num_connections: 0, avg_specialization: 0, total_activations: 0 });
                }
            }, 5000);

            // Main update loop
            function updateDisplay() {
                if (network) {
                    const clusterId = document.getElementById('clusterId').value;
                    if (clusterId) {
                        // Update existing metrics
                        const state = network.get_cluster_state(clusterId);
                        if (state) {
                            updateMetrics(state);
                            drawTopologyChart(state.num_nodes, state.num_connections);
                        }
                        
                        // Update blockchain metrics
                        updateBlockchainStats();
                        
                        // Update vector database stats
                        updateVectorDBStats();
                        
                        // Update P2P network stats and check auto-connections
                        updateP2PNetworkStats();
                        
                        // Monitor auto-connection progress
                        monitorAutoConnection();
                        
                        // Update node availability stats
                        updateNodeAvailabilityStats();
                        
                        // Process training
                        network.step_simulation(16.0); // ~60fps
                    }
                }
            }
            
            // Start the update loop
            setInterval(updateDisplay, 1000); // Update every second

            function updateBlockchainStats() {
                // Update blockchain metrics if available
                if (network) {
                    try {
                        const balance = network.get_account_balance();
                        document.getElementById('accountBalanceMetric').textContent = balance.toFixed(2);
                        
                        const blockchainStats = network.get_blockchain_stats();
                        if (blockchainStats) {
                            document.getElementById('totalBlocksMetric').textContent = blockchainStats.total_blocks;
                            document.getElementById('memoryCapsulesMetric').textContent = blockchainStats.total_memory_capsules;
                        }
                    } catch (e) {
                        // Blockchain stats not available yet, ignore silently
                    }
                }
            }
            
            function updateVectorDBStats() {
                // Update vector database stats if available
                if (network) {
                    try {
                        // Vector DB stats would go here when implemented
                        // For now, this is a placeholder
                    } catch (e) {
                        // Vector DB stats not available yet, ignore silently
                    }
                }
            }

            // Event handlers (continued)
            document.getElementById('closeWebRTCConnection').addEventListener('click', () => {
                const connectedPeer = document.getElementById('connectedPeer').textContent;
                if (network && connectedPeer !== 'None') {
                    const success = network.close_webrtc_connection(connectedPeer);
                    if (success) {
                        addLog(`üîí Closed WebRTC connection to peer: ${connectedPeer}`, 'p2p');
                        setStatus('üåê WebRTC disconnected', 'ready');
                        document.getElementById('connectedPeer').textContent = 'None';
                        updateNodeAvailabilityStats();
                    } else {
                        addLog(`‚ùå Failed to close WebRTC connection to peer: ${connectedPeer}`, 'error');
                    }
                } else {
                    addLog('‚ùå No active connection to close', 'warning');
                }
            });
        }).catch(error => {
            setStatus('‚ùå Failed to load WASM module', 'error');
            addLog(`Error: ${error.message}`, 'error');
            console.error(error);
        });
    </script>
</body>
</html>