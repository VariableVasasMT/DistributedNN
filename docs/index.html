<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Distributed Neural Network WASM Demo with Blockchain</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }
        
        h1 {
            text-align: center;
            color: #fff;
            margin-bottom: 10px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .subtitle {
            text-align: center;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 30px;
            font-style: italic;
        }
        
        .control-panel {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-group {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .control-group h3 {
            margin-top: 0;
            color: #fff;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 10px;
        }
        
        input, button, select {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }
        
        input[readonly] {
            background: rgba(200, 200, 200, 0.7);
            color: #555;
            cursor: not-allowed;
            border: 2px solid rgba(255, 255, 255, 0.5);
        }
        
        input[readonly]:focus {
            outline: 2px solid #FFD93D;
        }
        
        button {
            background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .blockchain-button {
            background: linear-gradient(45deg, #FFD93D, #6BCF7F);
        }
        
        .visualization {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .chart-container {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .chart-container h4 {
            margin-top: 0;
            color: #fff;
            text-align: center;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .metric-card {
            background: rgba(255, 255, 255, 0.15);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .metric-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #FFD93D;
            display: block;
        }
        
        .metric-label {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 5px;
        }
        
        .blockchain-metric {
            border: 2px solid #FFD93D;
        }
        
        .log-container {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            padding: 15px;
            height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .log-entry {
            margin-bottom: 5px;
            color: #00ff88;
        }
        
        .log-entry.error {
            color: #ff6b6b;
        }
        
        .log-entry.warning {
            color: #ffd93d;
        }
        
        .log-entry.blockchain {
            color: #FFD93D;
            font-weight: bold;
        }
        
        .status {
            text-align: center;
            font-weight: bold;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 20px;
        }
        
        .status.loading {
            background: rgba(255, 217, 61, 0.3);
            color: #FFD93D;
        }
        
        .status.ready {
            background: rgba(0, 255, 136, 0.3);
            color: #00ff88;
        }
        
        .status.error {
            background: rgba(255, 107, 107, 0.3);
            color: #ff6b6b;
        }
        
        .network-viz {
            width: 100%;
            height: 250px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.2);
        }
        
        @media (max-width: 768px) {
            .control-panel,
            .visualization {
                grid-template-columns: 1fr;
            }
            
            .metrics {
                grid-template-columns: 1fr;
            }
        }
        
        .log-p2p { color: #00BCD4; }
        .log-p2p::before { content: "üåê "; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß†‚õìÔ∏è Distributed Neural Network with Blockchain</h1>
        <p class="subtitle">Forward-Only Threshold-Gating Architecture with Smart Contracts & Incentives</p>
        
        <div id="status" class="status loading">
            üîÑ Loading WASM module...
        </div>
        
        <div class="control-panel">
            <div class="control-group">
                <h3>üîß Network Configuration</h3>
                <label>Device ID (auto-generated):</label>
                <input type="text" id="deviceId" placeholder="Loading device ID..." readonly>
                
                <label>Cluster ID:</label>
                <input type="text" id="clusterId" value="main_cluster" placeholder="Enter cluster ID">
                
                <label>Number of Nodes:</label>
                <input type="number" id="nodeCount" value="8" min="2" max="50">
                
                <button id="createCluster">üöÄ Create Cluster</button>
            </div>
            
            <div class="control-group">
                <h3>üìä Input & Training</h3>
                <label>Input Data (comma separated):</label>
                <input type="text" id="inputData" value="0.5, 0.3, 0.8, 0.2" placeholder="e.g., 0.1, 0.5, 0.9, 0.3">
                
                <label>Error Signal:</label>
                <input type="number" id="errorSignal" value="0.1" step="0.01" min="-1" max="1">
                
                <button id="processInput">‚ö° Process Input</button>
                <button id="updateError">üìâ Update Error</button>
                <button id="stepSimulation">üéØ Step Simulation</button>
            </div>

            <div class="control-group">
                <h3>‚õìÔ∏è Blockchain Operations</h3>
                <label>Node Owner (for borrowing):</label>
                <input type="text" id="nodeOwner" value="remote_device_001" placeholder="Node owner device ID">
                
                <label>Borrowing Duration (hours):</label>
                <input type="number" id="borrowDuration" value="2" min="0.5" max="24" step="0.5">
                
                <button id="borrowNode" class="blockchain-button">ü§ù Borrow Node</button>
                <button id="mineBlock" class="blockchain-button">‚õèÔ∏è Mine Block</button>
                <button id="validateChain" class="blockchain-button">‚úÖ Validate Chain</button>
            </div>

            <div class="control-section">
                <h3>üåê True Peer-to-Peer WebRTC Networking</h3>
                <div class="architecture-note" style="background: rgba(255, 215, 0, 0.1); border: 2px solid #ffd700; border-radius: 10px; padding: 15px; margin: 10px 0;">
                    <h4 style="color: #ffd700; margin-top: 0;">üîß True P2P Architecture:</h4>
                    <p style="margin: 5px 0;"><strong>‚úÖ Signaling Server:</strong> Used ONLY for initial discovery and WebRTC handshake</p>
                    <p style="margin: 5px 0;"><strong>‚úÖ Data Transfer:</strong> Direct peer-to-peer via WebRTC data channels</p>
                    <p style="margin: 5px 0;"><strong>‚úÖ No Relay:</strong> After handshake, ALL data flows directly between devices</p>
                    <p style="margin: 5px 0;"><strong>üîí Security:</strong> WebRTC provides built-in DTLS encryption</p>
                </div>
                <div class="control-row">
                    <input type="text" id="signalingServerUrl" placeholder="ws://localhost:8080" value="ws://localhost:8080" style="width: 300px;">
                    <button id="configureSignaling" class="btn btn-primary">Configure Signaling Server</button>
                    <button id="getWebRTCStats" class="btn btn-secondary">Get WebRTC Stats</button>
                </div>
                <div class="control-row">
                    <button id="startDiscovery" class="btn btn-secondary">Start Peer Discovery</button>
                    <input type="text" id="targetPeerId" placeholder="Target Peer ID" value="demo_device_002" style="width: 200px;">
                    <button id="initiateWebRTC" class="btn btn-accent">Initiate WebRTC Connection</button>
                    <button id="closeWebRTCConnection" class="btn btn-danger">Close Connection</button>
                </div>
                <div class="control-row">
                    <input type="text" id="messageText" placeholder="Message to send via WebRTC" value="Hello via direct P2P!" style="width: 300px;">
                    <button id="sendDirectMessage" class="btn btn-primary">Send Direct P2P Message</button>
                </div>
                <div class="control-row">
                    <input type="text" id="peerIdForRequest" placeholder="peer_device_id" style="width: 150px;">
                    <button id="requestNodeFromPeer" class="btn btn-accent">Request Node from Peer</button>
                    <button id="shareMemoryWithPeer" class="btn btn-accent">Share Memory Direct</button>
                </div>
                <div class="control-row">
                    <input type="text" id="collaborativePeers" placeholder="peer1,peer2,peer3" style="width: 200px;">
                    <input type="text" id="taskDescription" placeholder="Collaborative learning task" style="width: 200px;">
                    <button id="startCollabLearning" class="btn btn-primary">Start Collaborative Learning</button>
                </div>
                <div class="control-row">
                    <select id="errorUrgency">
                        <option value="1">Low Priority</option>
                        <option value="5" selected>Medium Priority</option>
                        <option value="9">High Priority</option>
                    </select>
                    <button id="propagateError" class="btn btn-warning">Propagate Error to Peers</button>
                    <button id="checkWebRTCConnections" class="btn btn-secondary">Check WebRTC Connections</button>
                </div>
                <div class="peer-list" style="background: rgba(255, 255, 255, 0.05); padding: 15px; border-radius: 5px; margin: 10px 0;">
                    <h4>üìã Discovered Peers:</h4>
                    <div id="discoveredPeers">No peers discovered yet</div>
                </div>
            </div>
        </div>
        
        <div class="metrics">
            <div class="metric-card">
                <span id="nodeCountMetric" class="metric-value">0</span>
                <div class="metric-label">Active Nodes</div>
            </div>
            <div class="metric-card">
                <span id="connectionCountMetric" class="metric-value">0</span>
                <div class="metric-label">Connections</div>
            </div>
            <div class="metric-card">
                <span id="avgSpecializationMetric" class="metric-value">0.00</span>
                <div class="metric-label">Avg Specialization</div>
            </div>
            <div class="metric-card">
                <span id="totalActivationsMetric" class="metric-value">0</span>
                <div class="metric-label">Total Activations</div>
            </div>
            <div class="metric-card blockchain-metric">
                <span id="accountBalanceMetric" class="metric-value">0.00</span>
                <div class="metric-label">üí∞ Account Credits</div>
            </div>
            <div class="metric-card blockchain-metric">
                <span id="totalBlocksMetric" class="metric-value">0</span>
                <div class="metric-label">‚õìÔ∏è Total Blocks</div>
            </div>
            <div class="metric-card blockchain-metric">
                <span id="memoryCapsulesMetric" class="metric-value">0</span>
                <div class="metric-label">üì¶ Memory Capsules</div>
            </div>
        </div>
        
        <div class="metrics-section">
            <h3>üìä P2P Network Stats</h3>
            <canvas id="p2pStatsChart" width="400" height="200"></canvas>
            <div id="p2pMetrics" class="metrics-display">
                <div>Connected Peers: <span id="connectedPeers">0</span></div>
                <div>Known Peers: <span id="knownPeers">0</span></div>
                <div>Pending Messages: <span id="pendingMessages">0</span></div>
                <div>Avg Latency: <span id="avgLatency">0ms</span></div>
                <div>Network Health: <span id="networkHealth">0%</span></div>
            </div>
        </div>
        
        <div class="visualization">
            <div class="chart-container">
                <h4>üìà Network Activity</h4>
                <canvas id="activityChart" class="network-viz"></canvas>
            </div>
            <div class="chart-container">
                <h4>üåê Network Topology</h4>
                <canvas id="topologyChart" class="network-viz"></canvas>
            </div>
            <div class="chart-container">
                <h4>‚õìÔ∏è Blockchain Stats</h4>
                <canvas id="blockchainChart" class="network-viz"></canvas>
            </div>
        </div>
        
        <div class="chart-container">
            <h4>üìù System Log</h4>
            <div id="logContainer" class="log-container"></div>
        </div>
    </div>

    <script type="module">
        import init, { DistributedNeuralNetwork, P2PNetwork, WebRTCManager } from './pkg/distributed_neural_network.js';
        
        let network = null;
        let webrtcManager = null;
        let activityHistory = [];
        let errorHistory = [];
        let blockchainHistory = [];
        let currentDeviceId = null;
        
        // Generate or retrieve persistent device ID
        function initializeDeviceId() {
            const DEVICE_ID_KEY = 'dnn_device_id';
            let deviceId = localStorage.getItem(DEVICE_ID_KEY);
            
            if (!deviceId) {
                // Generate random device ID with timestamp and random components
                const timestamp = Date.now().toString(36);
                const randomPart = Math.random().toString(36).substr(2, 8);
                const deviceType = navigator.userAgent.includes('Mobile') ? 'mobile' : 'desktop';
                deviceId = `${deviceType}_${timestamp}_${randomPart}`;
                
                localStorage.setItem(DEVICE_ID_KEY, deviceId);
                addLog(`üÜî Generated new device ID: ${deviceId}`, 'info');
            } else {
                addLog(`üÜî Retrieved existing device ID: ${deviceId}`, 'info');
            }
            
            currentDeviceId = deviceId;
            const deviceIdInput = document.getElementById('deviceId');
            deviceIdInput.value = deviceId;
            deviceIdInput.readOnly = true;
            deviceIdInput.title = 'Device ID is automatically generated and cannot be changed';
            
            return deviceId;
        }
        
        // Monitor for device ID tampering attempts
        function monitorDeviceIdChanges() {
            const deviceIdInput = document.getElementById('deviceId');
            
            // Prevent any changes to the device ID
            deviceIdInput.addEventListener('input', (e) => {
                if (e.target.value !== currentDeviceId) {
                    addLog('‚ö†Ô∏è Device ID cannot be changed! Resetting...', 'warning');
                    e.target.value = currentDeviceId;
                    
                    // Reset network if it exists
                    if (network) {
                        addLog('üîÑ Network reset due to device ID tampering attempt', 'warning');
                        network = null;
                        webrtcManager = null;
                        setStatus('üîÑ Network reset - create cluster again', 'loading');
                        
                        // Clear metrics
                        updateMetrics({ num_nodes: 0, num_connections: 0, avg_specialization: 0, total_activations: 0 });
                    }
                }
            });
            
            // Also prevent paste events
            deviceIdInput.addEventListener('paste', (e) => {
                e.preventDefault();
                addLog('‚ö†Ô∏è Device ID cannot be changed!', 'warning');
            });
            
            // And keydown events
            deviceIdInput.addEventListener('keydown', (e) => {
                // Allow only navigation keys, not editing
                const allowedKeys = ['Tab', 'ArrowLeft', 'ArrowRight', 'Home', 'End'];
                if (!allowedKeys.includes(e.key)) {
                    e.preventDefault();
                }
            });
        }
        
        // Status management
        function setStatus(message, type = 'loading') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
        }
        
        // Logging
        function addLog(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
            
            // Keep only last 100 messages
            while (logContainer.children.length > 100) {
                logContainer.removeChild(logContainer.firstChild);
            }
        }
        
        // Update metrics display
        function updateMetrics(state) {
            document.getElementById('nodeCountMetric').textContent = state.num_nodes;
            document.getElementById('connectionCountMetric').textContent = state.num_connections;
            document.getElementById('avgSpecializationMetric').textContent = state.avg_specialization.toFixed(3);
            document.getElementById('totalActivationsMetric').textContent = state.total_activations;
            
            // Update blockchain metrics
            if (network) {
                const balance = network.get_account_balance();
                document.getElementById('accountBalanceMetric').textContent = balance.toFixed(2);
                
                const blockchainStats = network.get_blockchain_stats();
                if (blockchainStats) {
                    document.getElementById('totalBlocksMetric').textContent = blockchainStats.total_blocks;
                    document.getElementById('memoryCapsulesMetric').textContent = blockchainStats.total_memory_capsules;
                }
            }
        }
        
        // Visualization functions
        function drawActivityChart() {
            const canvas = document.getElementById('activityChart');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (activityHistory.length < 2) return;
            
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            const maxVal = Math.max(...activityHistory);
            const minVal = Math.min(...activityHistory);
            const range = maxVal - minVal || 1;
            
            for (let i = 0; i < activityHistory.length; i++) {
                const x = (i / (activityHistory.length - 1)) * canvas.width;
                const y = canvas.height - ((activityHistory[i] - minVal) / range) * canvas.height;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            
            ctx.stroke();
            
            // Draw error history
            if (errorHistory.length > 1) {
                ctx.strokeStyle = '#ff6b6b';
                ctx.lineWidth = 1;
                ctx.beginPath();
                
                const maxError = Math.max(...errorHistory);
                const minError = Math.min(...errorHistory);
                const errorRange = maxError - minError || 1;
                
                for (let i = 0; i < errorHistory.length; i++) {
                    const x = (i / (errorHistory.length - 1)) * canvas.width;
                    const y = canvas.height - ((errorHistory[i] - minError) / errorRange) * canvas.height;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.stroke();
            }
        }
        
        function drawTopologyChart(nodeCount, connectionCount) {
            const canvas = document.getElementById('topologyChart');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (nodeCount === 0) return;
            
            // Draw nodes in a circle
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(canvas.width, canvas.height) / 3;
            
            const nodes = [];
            for (let i = 0; i < nodeCount; i++) {
                const angle = (i / nodeCount) * 2 * Math.PI;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                nodes.push({ x, y });
            }
            
            // Draw connections (simplified)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            const connectionsPerNode = Math.min(3, Math.floor(connectionCount / nodeCount));
            
            for (let i = 0; i < nodeCount; i++) {
                for (let j = 1; j <= connectionsPerNode; j++) {
                    const targetIndex = (i + j) % nodeCount;
                    ctx.beginPath();
                    ctx.moveTo(nodes[i].x, nodes[i].y);
                    ctx.lineTo(nodes[targetIndex].x, nodes[targetIndex].y);
                    ctx.stroke();
                }
            }
            
            // Draw nodes
            ctx.fillStyle = '#FFD93D';
            for (const node of nodes) {
                ctx.beginPath();
                ctx.arc(node.x, node.y, 6, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

        function drawBlockchainChart() {
            const canvas = document.getElementById('blockchainChart');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (!network) return;
            
            const stats = network.get_blockchain_stats();
            if (!stats) return;
            
            // Draw simple blockchain visualization
            const blockWidth = 40;
            const blockHeight = 30;
            const blockSpacing = 10;
            const startX = 20;
            const startY = canvas.height / 2;
            
            ctx.fillStyle = '#FFD93D';
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 2;
            
            for (let i = 0; i < Math.min(stats.total_blocks, 10); i++) {
                const x = startX + i * (blockWidth + blockSpacing);
                const y = startY - blockHeight / 2;
                
                // Draw block
                ctx.fillRect(x, y, blockWidth, blockHeight);
                ctx.strokeRect(x, y, blockWidth, blockHeight);
                
                // Draw block number
                ctx.fillStyle = '#000';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(i.toString(), x + blockWidth/2, y + blockHeight/2 + 4);
                ctx.fillStyle = '#FFD93D';
                
                // Draw connection to next block
                if (i < Math.min(stats.total_blocks - 1, 9)) {
                    ctx.beginPath();
                    ctx.moveTo(x + blockWidth, y + blockHeight/2);
                    ctx.lineTo(x + blockWidth + blockSpacing, y + blockHeight/2);
                    ctx.stroke();
                }
            }
            
            // Draw stats text
            ctx.fillStyle = '#FFF';
            ctx.font = '14px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`Blocks: ${stats.total_blocks}`, 20, 30);
            ctx.fillText(`Transactions: ${stats.total_transactions}`, 20, 50);
            ctx.fillText(`Memory Capsules: ${stats.total_memory_capsules}`, 20, 70);
            ctx.fillText(`Accounts: ${stats.total_accounts}`, 20, 90);
        }
        
        // Event handlers
        document.getElementById('createCluster').addEventListener('click', () => {
            const deviceId = currentDeviceId; // Use the persistent device ID
            const clusterId = document.getElementById('clusterId').value;
            const nodeCount = parseInt(document.getElementById('nodeCount').value);
            
            if (!deviceId) {
                addLog('‚ùå Device ID not initialized!', 'error');
                return;
            }
            
            if (!network) {
                network = new DistributedNeuralNetwork(deviceId);
                webrtcManager = new WebRTCManager(deviceId);
                addLog(`Created network for device: ${deviceId}`, 'blockchain');
                addLog(`Initialized WebRTC manager for device: ${deviceId}`, 'p2p');
            }
            
            const success = network.create_cluster(clusterId, nodeCount);
            if (success) {
                addLog(`Created cluster '${clusterId}' with ${nodeCount} nodes`);
                setStatus('üü¢ Network ready', 'ready');
                
                // Update visualization
                const state = network.get_cluster_state(clusterId);
                if (state) {
                    updateMetrics(state);
                    drawTopologyChart(nodeCount, state.num_connections);
                    drawBlockchainChart();
                }
            } else {
                addLog('Failed to create cluster', 'error');
            }
        });
        
        document.getElementById('processInput').addEventListener('click', () => {
            if (!network) {
                addLog('Create a network first!', 'error');
                return;
            }
            
            const clusterId = document.getElementById('clusterId').value;
            const inputStr = document.getElementById('inputData').value;
            const inputData = inputStr.split(',').map(x => parseFloat(x.trim()));
            
            const outputs = network.process_input(clusterId, inputData);
            const avgOutput = outputs.reduce((sum, val) => sum + val, 0) / outputs.length;
            
            activityHistory.push(avgOutput);
            if (activityHistory.length > 100) {
                activityHistory.shift();
            }
            
            addLog(`Processed input: [${inputData.join(', ')}] ‚Üí avg output: ${avgOutput.toFixed(4)}`);
            
            // Update metrics
            const state = network.get_cluster_state(clusterId);
            if (state) {
                updateMetrics(state);
                drawTopologyChart(state.num_nodes, state.num_connections);
            }
            
            drawActivityChart();
            drawBlockchainChart();
        });
        
        document.getElementById('updateError').addEventListener('click', () => {
            if (!network) {
                addLog('Create a network first!', 'error');
                return;
            }
            
            const clusterId = document.getElementById('clusterId').value;
            const error = parseFloat(document.getElementById('errorSignal').value);
            
            network.update_error_signal(clusterId, error);
            
            errorHistory.push(Math.abs(error));
            if (errorHistory.length > 100) {
                errorHistory.shift();
            }
            
            addLog(`Updated error signal: ${error}`);
            drawActivityChart();
        });
        
        document.getElementById('stepSimulation').addEventListener('click', () => {
            if (!network) {
                addLog('Create a network first!', 'error');
                return;
            }
            
            network.step_simulation(1.0);
            addLog('Stepped simulation forward');
            
            // Update metrics
            const clusterId = document.getElementById('clusterId').value;
            const state = network.get_cluster_state(clusterId);
            if (state) {
                updateMetrics(state);
            }
        });

        document.getElementById('borrowNode').addEventListener('click', () => {
            if (!network) {
                addLog('Create a network first!', 'error');
                return;
            }
            
            const nodeOwner = document.getElementById('nodeOwner').value;
            const duration = parseFloat(document.getElementById('borrowDuration').value);
            const nodeId = 'remote_node_001';
            
            const borrowingId = network.request_node_borrowing(nodeOwner, nodeId, duration);
            if (borrowingId) {
                addLog(`‚úÖ Node borrowing approved: ${borrowingId}`, 'blockchain');
                updateMetrics({ num_nodes: 0, num_connections: 0, avg_specialization: 0, total_activations: 0 });
            } else {
                addLog('‚ùå Node borrowing request denied', 'error');
            }
        });

        document.getElementById('mineBlock').addEventListener('click', () => {
            if (!network) {
                addLog('Create a network first!', 'error');
                return;
            }
            
            const blockHash = network.mine_block();
            if (blockHash) {
                addLog(`‚õèÔ∏è Mined new block: ${blockHash}`, 'blockchain');
                drawBlockchainChart();
                updateMetrics({ num_nodes: 0, num_connections: 0, avg_specialization: 0, total_activations: 0 });
            } else {
                addLog('No pending transactions to mine', 'warning');
            }
        });

        document.getElementById('validateChain').addEventListener('click', () => {
            if (!network) {
                addLog('Create a network first!', 'error');
                return;
            }
            
            const isValid = network.validate_blockchain();
            if (isValid) {
                addLog('‚úÖ Blockchain validation passed', 'blockchain');
            } else {
                addLog('‚ùå Blockchain validation failed!', 'error');
            }
        });
        
        // P2P Networking event handlers
        document.getElementById('configureSignaling').addEventListener('click', () => {
            const signalingUrl = document.getElementById('signalingServerUrl').value.trim();
            if (network && signalingUrl) {
                try {
                    const success = network.configure_signaling_server(signalingUrl);
                    if (success) {
                        addLog(`üåê Configured signaling server: ${signalingUrl}`, 'p2p');
                        setStatus('üü¢ Signaling server configured', 'ready');
                    } else {
                        addLog('‚ùå Failed to configure signaling server', 'error');
                    }
                } catch (e) {
                    addLog(`‚ùå Error configuring signaling server: ${e.message}`, 'error');
                }
            } else if (!signalingUrl) {
                addLog('‚ùå Please enter a signaling server URL', 'error');
            } else {
                addLog('‚ùå Create a network first!', 'error');
            }
        });

        document.getElementById('startDiscovery').addEventListener('click', () => {
            if (network) {
                // Configure signaling server before starting discovery if not already configured
                const signalingUrl = document.getElementById('signalingServerUrl').value.trim();
                if (signalingUrl) {
                    network.configure_signaling_server(signalingUrl);
                    addLog(`üåê Using signaling server: ${signalingUrl}`, 'p2p');
                }
                
                const success = network.start_peer_discovery();
                if (success) {
                    addLog('üîç Started peer discovery protocol', 'p2p');
                    setStatus('üåê Discovering peers', 'connecting');
                    
                    // Update discovered peers display
                    setTimeout(() => {
                        const peers = JSON.parse(network.get_discovered_peers());
                        updateDiscoveredPeers(peers);
                        addLog(`üîç Found ${peers.length} peers`, 'p2p');
                    }, 1000);
                } else {
                    addLog('‚ùå Failed to start peer discovery', 'error');
                }
            } else {
                addLog('‚ùå Create a network first!', 'error');
            }
        });

        function updateDiscoveredPeers(peers) {
            const peerContainer = document.getElementById('discoveredPeers');
            if (peers.length === 0) {
                peerContainer.innerHTML = 'No peers discovered yet';
                return;
            }
            
            peerContainer.innerHTML = peers.map(peer => `
                <div style="background: rgba(255, 255, 255, 0.1); padding: 10px; margin: 5px 0; border-radius: 5px; display: flex; justify-content: space-between; align-items: center;">
                    <span><strong>${peer.device_id}</strong> - ${peer.capabilities.join(', ')}</span>
                    <button onclick="connectToPeer('${peer.device_id}')" style="padding: 5px 10px; background: #9C27B0; color: white; border: none; border-radius: 3px; cursor: pointer;">Connect</button>
                </div>
            `).join('');
        }

        window.connectToPeer = function(peerId) {
            document.getElementById('targetPeerId').value = peerId;
            if (webrtcManager) {
                addLog(`üîó Initiating WebRTC connection to: ${peerId}`, 'p2p');
                // This would trigger the WebRTC connection process
                document.getElementById('initiateWebRTC').click();
            }
        };

        document.getElementById('initiateWebRTC').addEventListener('click', () => {
            const peerId = document.getElementById('targetPeerId').value;
            if (network && peerId) {
                const success = network.initiate_webrtc_connection(peerId);
                if (success) {
                    addLog(`ü§ù Initiated WebRTC connection to peer: ${peerId}`, 'p2p');
                    setStatus('üåê WebRTC connected', 'ready');
                } else {
                    addLog(`‚ùå Failed to initiate WebRTC connection to peer: ${peerId}`, 'error');
                }
            }
        });

        document.getElementById('closeWebRTCConnection').addEventListener('click', () => {
            const peerId = document.getElementById('targetPeerId').value;
            if (network && peerId) {
                const success = network.close_webrtc_connection(peerId);
                if (success) {
                    addLog(`üîí Closed WebRTC connection to peer: ${peerId}`, 'p2p');
                    setStatus('üåê WebRTC disconnected', 'ready');
                } else {
                    addLog(`‚ùå Failed to close WebRTC connection to peer: ${peerId}`, 'error');
                }
            }
        });

        document.getElementById('sendDirectMessage').addEventListener('click', () => {
            const message = document.getElementById('messageText').value;
            const peerId = document.getElementById('targetPeerId').value;
            if (network && message && peerId) {
                try {
                    network.send_direct_message(message);
                    addLog(`üì§ Sent direct P2P message to ${peerId}: ${message}`, 'p2p');
                } catch (error) {
                    addLog(`‚ùå Failed to send direct message: ${error}`, 'error');
                }
            } else {
                addLog('‚ùå Enter peer ID and message first', 'error');
            }
        });

        document.getElementById('requestNodeFromPeer').addEventListener('click', () => {
            const peerId = document.getElementById('peerIdForRequest').value;
            if (network && peerId) {
                const requestId = network.request_node_from_peer(peerId, 'inference', 30);
                if (requestId) {
                    addLog(`üì§ Requested node from peer ${peerId}, request ID: ${requestId}`, 'p2p');
                } else {
                    addLog(`‚ùå Failed to request node from peer: ${peerId}`, 'error');
                }
            }
        });

        document.getElementById('shareMemoryWithPeer').addEventListener('click', () => {
            const peerId = document.getElementById('peerIdForRequest').value;
            const clusterId = document.getElementById('clusterId').value;
            if (network && peerId && clusterId) {
                const success = network.share_memory_with_peer(peerId, clusterId);
                if (success) {
                    addLog(`üíæ Shared memory capsule with peer: ${peerId}`, 'p2p');
                } else {
                    addLog(`‚ùå Failed to share memory with peer: ${peerId}`, 'error');
                }
            }
        });

        document.getElementById('startCollabLearning').addEventListener('click', () => {
            const peerList = document.getElementById('collaborativePeers').value;
            const taskDesc = document.getElementById('taskDescription').value;
            if (network && peerList && taskDesc) {
                const peerIds = peerList.split(',').map(p => p.trim());
                const sessionId = network.start_collaborative_learning(peerIds, taskDesc);
                if (sessionId) {
                    addLog(`üéØ Started collaborative learning session: ${sessionId}`, 'p2p');
                    addLog(`üìö Task: ${taskDesc}`, 'training');
                    addLog(`üë• Participants: ${peerIds.length}`, 'training');
                } else {
                    addLog('‚ùå Failed to start collaborative learning', 'error');
                }
            }
        });

        document.getElementById('propagateError').addEventListener('click', () => {
            const clusterId = document.getElementById('clusterId').value;
            const urgency = parseInt(document.getElementById('errorUrgency').value);
            if (network && clusterId) {
                const propagatedCount = network.propagate_error_to_peers(clusterId, urgency);
                addLog(`üì° Error propagated to ${propagatedCount} peers (urgency: ${urgency})`, 'p2p');
            }
        });

        document.getElementById('checkWebRTCConnections').addEventListener('click', () => {
            const peerId = document.getElementById('targetPeerId').value;
            if (network && peerId) {
                const connected = network.check_webrtc_connections();
                addLog(`üîó Connection to ${peerId}: ${connected ? 'CONNECTED ‚úÖ' : 'NOT CONNECTED ‚ùå'}`, 
                       connected ? 'p2p' : 'error');
            } else {
                addLog('‚ùå Enter peer ID first', 'error');
            }
        });

        document.getElementById('getWebRTCStats').addEventListener('click', () => {
            if (webrtcManager) {
                try {
                    const stats = JSON.parse(webrtcManager.get_connection_stats());
                    addLog(`üìä WebRTC Stats: ${JSON.stringify(stats, null, 2)}`, 'p2p');
                } catch (error) {
                    addLog(`‚ùå Failed to get WebRTC stats: ${error}`, 'error');
                }
            } else {
                addLog('‚ùå Create a network first!', 'error');
            }
        });

        // Update P2P network visualization
        function updateP2PNetworkStats() {
            if (!network) return;

            try {
                const stats = network.get_p2p_network_stats();
                if (stats) {
                    document.getElementById('connectedPeers').textContent = stats.connected_peers || 0;
                    document.getElementById('knownPeers').textContent = stats.known_peers || 0;
                    document.getElementById('pendingMessages').textContent = stats.pending_messages || 0;
                    document.getElementById('avgLatency').textContent = `${Math.round(stats.average_latency || 0)}ms`;
                    document.getElementById('networkHealth').textContent = `${Math.round((stats.network_health || 0) * 100)}%`;
                    
                    drawP2PStatsChart(stats);
                }
            } catch (e) {
                console.warn('Failed to update P2P stats:', e);
            }
        }

        function drawP2PStatsChart(stats) {
            const canvas = document.getElementById('p2pStatsChart');
            const ctx = canvas.getContext('2d');
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Background
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Network health visualization
            const healthPercent = (stats.network_health || 0) * 100;
            const healthColor = healthPercent > 70 ? '#4CAF50' : healthPercent > 40 ? '#FF9800' : '#F44336';
            
            // Health bar
            ctx.fillStyle = healthColor;
            ctx.fillRect(20, 20, (canvas.width - 40) * (healthPercent / 100), 30);
            
            // Health border
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(20, 20, canvas.width - 40, 30);
            
            // Health label
            ctx.fillStyle = '#fff';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`Network Health: ${Math.round(healthPercent)}%`, canvas.width / 2, 40);
            
            // Connection stats
            const connectedPeers = stats.connected_peers || 0;
            const knownPeers = stats.known_peers || 0;
            
            // Peer connection visualization
            ctx.fillStyle = '#00BCD4';
            ctx.fillRect(20, 70, Math.min(connectedPeers * 30, canvas.width - 40), 20);
            
            ctx.fillStyle = 'rgba(156, 39, 176, 0.5)';
            ctx.fillRect(20, 100, Math.min(knownPeers * 20, canvas.width - 40), 20);
            
            // Labels
            ctx.fillStyle = '#fff';
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`Connected: ${connectedPeers}`, 25, 85);
            ctx.fillText(`Known: ${knownPeers}`, 25, 115);
            
            // Latency indicator
            const avgLatency = stats.average_latency || 0;
            const latencyColor = avgLatency < 100 ? '#4CAF50' : avgLatency < 300 ? '#FF9800' : '#F44336';
            
            ctx.fillStyle = latencyColor;
            ctx.fillRect(20, 140, Math.min(avgLatency / 2, canvas.width - 40), 15);
            
            ctx.fillStyle = '#fff';
            ctx.fillText(`Avg Latency: ${Math.round(avgLatency)}ms`, 25, 152);
        }
        
        // Initialize WASM module
        async function initializeDemo() {
            try {
                // Initialize device ID first
                initializeDeviceId();
                monitorDeviceIdChanges();
                
                await init();
                setStatus('üü¢ WASM module loaded successfully', 'ready');
                addLog('Distributed Neural Network with Blockchain WASM module initialized');
                addLog('Ready to create networks and process data');
                addLog(`üîí Device ID locked: ${currentDeviceId}`, 'info');
                
                // Enable controls
                document.querySelectorAll('button').forEach(btn => btn.disabled = false);
                
            } catch (error) {
                setStatus('‚ùå Failed to load WASM module', 'error');
                addLog(`Error: ${error.message}`, 'error');
                console.error(error);
            }
        }
        
        // Start demo
        initializeDemo();
        
        // Auto-run demo after 2 seconds if user hasn't interacted
        setTimeout(() => {
            if (!network) {
                document.getElementById('createCluster').click();
                setTimeout(() => {
                    document.getElementById('processInput').click();
                }, 1000);
            }
        }, 2000);

        // Auto-update blockchain chart periodically
        setInterval(() => {
            if (network) {
                drawBlockchainChart();
                updateMetrics({ num_nodes: 0, num_connections: 0, avg_specialization: 0, total_activations: 0 });
            }
        }, 5000);

        // Main update loop
        function updateDisplay() {
            if (network) {
                const clusterId = document.getElementById('clusterId').value;
                if (clusterId) {
                    // Update existing metrics
                    const state = network.get_cluster_state(clusterId);
                    if (state) {
                        updateMetrics(state);
                        drawTopologyChart(state.num_nodes, state.num_connections);
                    }
                    
                    // Update blockchain metrics
                    updateBlockchainStats();
                    
                    // Update vector database stats
                    updateVectorDBStats();
                    
                    // Update P2P network stats
                    updateP2PNetworkStats();
                    
                    // Process training
                    network.step_simulation(16.0); // ~60fps
                }
            }
        }
    </script>
</body>
</html> 