<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Distributed Neural Network WASM Demo</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }
        
        h1 {
            text-align: center;
            color: #fff;
            margin-bottom: 10px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .subtitle {
            text-align: center;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 30px;
            font-style: italic;
        }
        
        .control-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-group {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .control-group h3 {
            margin-top: 0;
            color: #fff;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 10px;
        }
        
        input, button, select {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }
        
        button {
            background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .visualization {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .chart-container {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .chart-container h4 {
            margin-top: 0;
            color: #fff;
            text-align: center;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .metric-card {
            background: rgba(255, 255, 255, 0.15);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .metric-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #FFD93D;
            display: block;
        }
        
        .metric-label {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 5px;
        }
        
        .log-container {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            padding: 15px;
            height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .log-entry {
            margin-bottom: 5px;
            color: #00ff88;
        }
        
        .log-entry.error {
            color: #ff6b6b;
        }
        
        .log-entry.warning {
            color: #ffd93d;
        }
        
        .status {
            text-align: center;
            font-weight: bold;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 20px;
        }
        
        .status.loading {
            background: rgba(255, 217, 61, 0.3);
            color: #FFD93D;
        }
        
        .status.ready {
            background: rgba(0, 255, 136, 0.3);
            color: #00ff88;
        }
        
        .status.error {
            background: rgba(255, 107, 107, 0.3);
            color: #ff6b6b;
        }
        
        .network-viz {
            width: 100%;
            height: 300px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.2);
        }
        
        @media (max-width: 768px) {
            .control-panel,
            .visualization {
                grid-template-columns: 1fr;
            }
            
            .metrics {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß† Distributed Neural Network</h1>
        <p class="subtitle">Forward-Only Threshold-Gating Architecture with Hierarchical Memory</p>
        
        <div id="status" class="status loading">
            üîÑ Loading WASM module...
        </div>
        
        <div class="control-panel">
            <div class="control-group">
                <h3>üîß Network Configuration</h3>
                <label>Device ID:</label>
                <input type="text" id="deviceId" value="browser_device_001" placeholder="Enter device ID">
                
                <label>Cluster ID:</label>
                <input type="text" id="clusterId" value="main_cluster" placeholder="Enter cluster ID">
                
                <label>Number of Nodes:</label>
                <input type="number" id="nodeCount" value="8" min="2" max="50">
                
                <button id="createCluster">üöÄ Create Cluster</button>
            </div>
            
            <div class="control-group">
                <h3>üìä Input & Training</h3>
                <label>Input Data (comma separated):</label>
                <input type="text" id="inputData" value="0.5, 0.3, 0.8, 0.2" placeholder="e.g., 0.1, 0.5, 0.9, 0.3">
                
                <label>Error Signal:</label>
                <input type="number" id="errorSignal" value="0.1" step="0.01" min="-1" max="1">
                
                <button id="processInput">‚ö° Process Input</button>
                <button id="updateError">üìâ Update Error</button>
                <button id="stepSimulation">üéØ Step Simulation</button>
            </div>
        </div>
        
        <div class="metrics">
            <div class="metric-card">
                <span id="nodeCountMetric" class="metric-value">0</span>
                <div class="metric-label">Active Nodes</div>
            </div>
            <div class="metric-card">
                <span id="connectionCountMetric" class="metric-value">0</span>
                <div class="metric-label">Connections</div>
            </div>
            <div class="metric-card">
                <span id="avgSpecializationMetric" class="metric-value">0.00</span>
                <div class="metric-label">Avg Specialization</div>
            </div>
            <div class="metric-card">
                <span id="totalActivationsMetric" class="metric-value">0</span>
                <div class="metric-label">Total Activations</div>
            </div>
        </div>
        
        <div class="visualization">
            <div class="chart-container">
                <h4>üìà Network Activity</h4>
                <canvas id="activityChart" class="network-viz"></canvas>
            </div>
            <div class="chart-container">
                <h4>üåê Network Topology</h4>
                <canvas id="topologyChart" class="network-viz"></canvas>
            </div>
        </div>
        
        <div class="chart-container">
            <h4>üìù System Log</h4>
            <div id="logContainer" class="log-container"></div>
        </div>
    </div>

    <script type="module">
        import init, { DistributedNeuralNetwork } from './pkg/distributed_neural_wasm.js';
        
        let network = null;
        let activityHistory = [];
        let errorHistory = [];
        
        // Status management
        function setStatus(message, type = 'loading') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
        }
        
        // Logging
        function addLog(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }
        
        // Update metrics display
        function updateMetrics(state) {
            document.getElementById('nodeCountMetric').textContent = state.num_nodes;
            document.getElementById('connectionCountMetric').textContent = state.num_connections;
            document.getElementById('avgSpecializationMetric').textContent = state.avg_specialization.toFixed(3);
            document.getElementById('totalActivationsMetric').textContent = state.total_activations;
        }
        
        // Simple visualization functions
        function drawActivityChart() {
            const canvas = document.getElementById('activityChart');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (activityHistory.length < 2) return;
            
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            const maxVal = Math.max(...activityHistory);
            const minVal = Math.min(...activityHistory);
            const range = maxVal - minVal || 1;
            
            for (let i = 0; i < activityHistory.length; i++) {
                const x = (i / (activityHistory.length - 1)) * canvas.width;
                const y = canvas.height - ((activityHistory[i] - minVal) / range) * canvas.height;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            
            ctx.stroke();
            
            // Draw error history
            if (errorHistory.length > 1) {
                ctx.strokeStyle = '#ff6b6b';
                ctx.lineWidth = 1;
                ctx.beginPath();
                
                const maxError = Math.max(...errorHistory);
                const minError = Math.min(...errorHistory);
                const errorRange = maxError - minError || 1;
                
                for (let i = 0; i < errorHistory.length; i++) {
                    const x = (i / (errorHistory.length - 1)) * canvas.width;
                    const y = canvas.height - ((errorHistory[i] - minError) / errorRange) * canvas.height;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.stroke();
            }
        }
        
        function drawTopologyChart(nodeCount, connectionCount) {
            const canvas = document.getElementById('topologyChart');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (nodeCount === 0) return;
            
            // Draw nodes in a circle
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(canvas.width, canvas.height) / 3;
            
            const nodes = [];
            for (let i = 0; i < nodeCount; i++) {
                const angle = (i / nodeCount) * 2 * Math.PI;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                nodes.push({ x, y });
            }
            
            // Draw connections (simplified)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            const connectionsPerNode = Math.min(3, Math.floor(connectionCount / nodeCount));
            
            for (let i = 0; i < nodeCount; i++) {
                for (let j = 1; j <= connectionsPerNode; j++) {
                    const targetIndex = (i + j) % nodeCount;
                    ctx.beginPath();
                    ctx.moveTo(nodes[i].x, nodes[i].y);
                    ctx.lineTo(nodes[targetIndex].x, nodes[targetIndex].y);
                    ctx.stroke();
                }
            }
            
            // Draw nodes
            ctx.fillStyle = '#FFD93D';
            for (const node of nodes) {
                ctx.beginPath();
                ctx.arc(node.x, node.y, 6, 0, 2 * Math.PI);
                ctx.fill();
            }
        }
        
        // Event handlers
        document.getElementById('createCluster').addEventListener('click', () => {
            const deviceId = document.getElementById('deviceId').value;
            const clusterId = document.getElementById('clusterId').value;
            const nodeCount = parseInt(document.getElementById('nodeCount').value);
            
            if (!network) {
                network = new DistributedNeuralNetwork(deviceId);
                addLog(`Created network for device: ${deviceId}`);
            }
            
            const success = network.create_cluster(clusterId, nodeCount);
            if (success) {
                addLog(`Created cluster '${clusterId}' with ${nodeCount} nodes`);
                setStatus('üü¢ Network ready', 'ready');
                
                // Update visualization
                const state = network.get_cluster_state(clusterId);
                if (state) {
                    updateMetrics(state);
                    drawTopologyChart(nodeCount, state.num_connections);
                }
            } else {
                addLog('Failed to create cluster', 'error');
            }
        });
        
        document.getElementById('processInput').addEventListener('click', () => {
            if (!network) {
                addLog('Create a network first!', 'error');
                return;
            }
            
            const clusterId = document.getElementById('clusterId').value;
            const inputStr = document.getElementById('inputData').value;
            const inputData = inputStr.split(',').map(x => parseFloat(x.trim()));
            
            const outputs = network.process_input(clusterId, inputData);
            const avgOutput = outputs.reduce((sum, val) => sum + val, 0) / outputs.length;
            
            activityHistory.push(avgOutput);
            if (activityHistory.length > 100) {
                activityHistory.shift();
            }
            
            addLog(`Processed input: [${inputData.join(', ')}] ‚Üí avg output: ${avgOutput.toFixed(4)}`);
            
            // Update metrics
            const state = network.get_cluster_state(clusterId);
            if (state) {
                updateMetrics(state);
                drawTopologyChart(state.num_nodes, state.num_connections);
            }
            
            drawActivityChart();
        });
        
        document.getElementById('updateError').addEventListener('click', () => {
            if (!network) {
                addLog('Create a network first!', 'error');
                return;
            }
            
            const clusterId = document.getElementById('clusterId').value;
            const error = parseFloat(document.getElementById('errorSignal').value);
            
            network.update_error_signal(clusterId, error);
            
            errorHistory.push(Math.abs(error));
            if (errorHistory.length > 100) {
                errorHistory.shift();
            }
            
            addLog(`Updated error signal: ${error}`);
            drawActivityChart();
        });
        
        document.getElementById('stepSimulation').addEventListener('click', () => {
            if (!network) {
                addLog('Create a network first!', 'error');
                return;
            }
            
            network.step_simulation(1.0);
            addLog('Stepped simulation forward');
            
            // Update metrics
            const clusterId = document.getElementById('clusterId').value;
            const state = network.get_cluster_state(clusterId);
            if (state) {
                updateMetrics(state);
            }
        });
        
        // Initialize WASM module
        async function initializeDemo() {
            try {
                await init();
                setStatus('üü¢ WASM module loaded successfully', 'ready');
                addLog('Distributed Neural Network WASM module initialized');
                addLog('Ready to create networks and process data');
                
                // Enable controls
                document.querySelectorAll('button').forEach(btn => btn.disabled = false);
                
            } catch (error) {
                setStatus('‚ùå Failed to load WASM module', 'error');
                addLog(`Error: ${error.message}`, 'error');
                console.error(error);
            }
        }
        
        // Start demo
        initializeDemo();
        
        // Auto-run demo after 2 seconds if user hasn't interacted
        setTimeout(() => {
            if (!network) {
                document.getElementById('createCluster').click();
                setTimeout(() => {
                    document.getElementById('processInput').click();
                }, 1000);
            }
        }, 2000);
    </script>
</body>
</html> 