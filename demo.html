<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Distributed Neural Network WASM Demo with Blockchain</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }
        
        h1 {
            text-align: center;
            color: #fff;
            margin-bottom: 10px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .subtitle {
            text-align: center;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 30px;
            font-style: italic;
        }
        
        .control-panel {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-group {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .control-group h3 {
            margin-top: 0;
            color: #fff;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 10px;
        }
        
        input, button, select {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }
        
        button {
            background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .blockchain-button {
            background: linear-gradient(45deg, #FFD93D, #6BCF7F);
        }
        
        .visualization {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .chart-container {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .chart-container h4 {
            margin-top: 0;
            color: #fff;
            text-align: center;
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .metric-card {
            background: rgba(255, 255, 255, 0.15);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .metric-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #FFD93D;
            display: block;
        }
        
        .metric-label {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 5px;
        }
        
        .blockchain-metric {
            border: 2px solid #FFD93D;
        }
        
        .log-container {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            padding: 15px;
            height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .log-entry {
            margin-bottom: 5px;
            color: #00ff88;
        }
        
        .log-entry.error {
            color: #ff6b6b;
        }
        
        .log-entry.warning {
            color: #ffd93d;
        }
        
        .log-entry.blockchain {
            color: #FFD93D;
            font-weight: bold;
        }
        
        .status {
            text-align: center;
            font-weight: bold;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 20px;
        }
        
        .status.loading {
            background: rgba(255, 217, 61, 0.3);
            color: #FFD93D;
        }
        
        .status.ready {
            background: rgba(0, 255, 136, 0.3);
            color: #00ff88;
        }
        
        .status.error {
            background: rgba(255, 107, 107, 0.3);
            color: #ff6b6b;
        }
        
        .network-viz {
            width: 100%;
            height: 250px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.2);
        }
        
        @media (max-width: 768px) {
            .control-panel,
            .visualization {
                grid-template-columns: 1fr;
            }
            
            .metrics {
                grid-template-columns: 1fr;
            }
        }
        
        .log-p2p { color: #00BCD4; }
        .log-p2p::before { content: "üåê "; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß†‚õìÔ∏è Distributed Neural Network with Blockchain</h1>
        <p class="subtitle">Forward-Only Threshold-Gating Architecture with Smart Contracts & Incentives</p>
        
        <div id="status" class="status loading">
            üîÑ Loading WASM module...
        </div>
        
        <div class="control-panel">
            <div class="control-group">
                <h3>üîß Network Configuration</h3>
                <label>Device ID:</label>
                <input type="text" id="deviceId" value="browser_device_001" placeholder="Enter device ID">
                
                <label>Cluster ID:</label>
                <input type="text" id="clusterId" value="main_cluster" placeholder="Enter cluster ID">
                
                <label>Number of Nodes:</label>
                <input type="number" id="nodeCount" value="8" min="2" max="50">
                
                <button id="createCluster">üöÄ Create Cluster</button>
            </div>
            
            <div class="control-group">
                <h3>üìä Input & Training</h3>
                <label>Input Data (comma separated):</label>
                <input type="text" id="inputData" value="0.5, 0.3, 0.8, 0.2" placeholder="e.g., 0.1, 0.5, 0.9, 0.3">
                
                <label>Error Signal:</label>
                <input type="number" id="errorSignal" value="0.1" step="0.01" min="-1" max="1">
                
                <button id="processInput">‚ö° Process Input</button>
                <button id="updateError">üìâ Update Error</button>
                <button id="stepSimulation">üéØ Step Simulation</button>
            </div>

            <div class="control-group">
                <h3>‚õìÔ∏è Blockchain Operations</h3>
                <label>Node Owner (for borrowing):</label>
                <input type="text" id="nodeOwner" value="remote_device_001" placeholder="Node owner device ID">
                
                <label>Borrowing Duration (hours):</label>
                <input type="number" id="borrowDuration" value="2" min="0.5" max="24" step="0.5">
                
                <button id="borrowNode" class="blockchain-button">ü§ù Borrow Node</button>
                <button id="mineBlock" class="blockchain-button">‚õèÔ∏è Mine Block</button>
                <button id="validateChain" class="blockchain-button">‚úÖ Validate Chain</button>
            </div>

            <div class="control-section">
                <h3>üåê P2P Networking</h3>
                <div class="control-row">
                    <button id="startDiscovery" class="btn btn-secondary">Start Peer Discovery</button>
                    <button id="connectPeer" class="btn btn-secondary">Connect to Peer</button>
                    <input type="text" id="peerConnectionInfo" placeholder='{"device_id":"peer1","ip_address":"192.168.1.100","port":8080,"public_key":"key","capabilities":["memory_sharing"],"reputation_score":1.0,"last_seen":0,"cluster_specializations":["general"]}' style="width: 400px;">
                </div>
                <div class="control-row">
                    <input type="text" id="peerIdForRequest" placeholder="peer_device_id" style="width: 150px;">
                    <button id="requestNodeFromPeer" class="btn btn-accent">Request Node from Peer</button>
                    <button id="shareMemoryWithPeer" class="btn btn-accent">Share Memory Direct</button>
                </div>
                <div class="control-row">
                    <input type="text" id="collaborativePeers" placeholder="peer1,peer2,peer3" style="width: 200px;">
                    <input type="text" id="taskDescription" placeholder="Collaborative learning task" style="width: 200px;">
                    <button id="startCollabLearning" class="btn btn-primary">Start Collaborative Learning</button>
                </div>
                <div class="control-row">
                    <select id="errorUrgency">
                        <option value="1">Low Priority</option>
                        <option value="5" selected>Medium Priority</option>
                        <option value="9">High Priority</option>
                    </select>
                    <button id="propagateError" class="btn btn-warning">Propagate Error to Peers</button>
                </div>
            </div>
        </div>
        
        <div class="metrics">
            <div class="metric-card">
                <span id="nodeCountMetric" class="metric-value">0</span>
                <div class="metric-label">Active Nodes</div>
            </div>
            <div class="metric-card">
                <span id="connectionCountMetric" class="metric-value">0</span>
                <div class="metric-label">Connections</div>
            </div>
            <div class="metric-card">
                <span id="avgSpecializationMetric" class="metric-value">0.00</span>
                <div class="metric-label">Avg Specialization</div>
            </div>
            <div class="metric-card">
                <span id="totalActivationsMetric" class="metric-value">0</span>
                <div class="metric-label">Total Activations</div>
            </div>
            <div class="metric-card blockchain-metric">
                <span id="accountBalanceMetric" class="metric-value">0.00</span>
                <div class="metric-label">üí∞ Account Credits</div>
            </div>
            <div class="metric-card blockchain-metric">
                <span id="totalBlocksMetric" class="metric-value">0</span>
                <div class="metric-label">‚õìÔ∏è Total Blocks</div>
            </div>
            <div class="metric-card blockchain-metric">
                <span id="memoryCapsulesMetric" class="metric-value">0</span>
                <div class="metric-label">üì¶ Memory Capsules</div>
            </div>
        </div>
        
        <div class="metrics-section">
            <h3>üìä P2P Network Stats</h3>
            <canvas id="p2pStatsChart" width="400" height="200"></canvas>
            <div id="p2pMetrics" class="metrics-display">
                <div>Connected Peers: <span id="connectedPeers">0</span></div>
                <div>Known Peers: <span id="knownPeers">0</span></div>
                <div>Pending Messages: <span id="pendingMessages">0</span></div>
                <div>Avg Latency: <span id="avgLatency">0ms</span></div>
                <div>Network Health: <span id="networkHealth">0%</span></div>
            </div>
        </div>
        
        <div class="visualization">
            <div class="chart-container">
                <h4>üìà Network Activity</h4>
                <canvas id="activityChart" class="network-viz"></canvas>
            </div>
            <div class="chart-container">
                <h4>üåê Network Topology</h4>
                <canvas id="topologyChart" class="network-viz"></canvas>
            </div>
            <div class="chart-container">
                <h4>‚õìÔ∏è Blockchain Stats</h4>
                <canvas id="blockchainChart" class="network-viz"></canvas>
            </div>
        </div>
        
        <div class="chart-container">
            <h4>üìù System Log</h4>
            <div id="logContainer" class="log-container"></div>
        </div>
    </div>

    <script type="module">
        import init, { DistributedNeuralNetwork } from './pkg/distributed_neural_wasm.js';
        
        let network = null;
        let activityHistory = [];
        let errorHistory = [];
        let blockchainHistory = [];
        
        // Status management
        function setStatus(message, type = 'loading') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
        }
        
        // Logging
        function addLog(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
            
            // Keep only last 100 messages
            while (logContainer.children.length > 100) {
                logContainer.removeChild(logContainer.firstChild);
            }
        }
        
        // Update metrics display
        function updateMetrics(state) {
            document.getElementById('nodeCountMetric').textContent = state.num_nodes;
            document.getElementById('connectionCountMetric').textContent = state.num_connections;
            document.getElementById('avgSpecializationMetric').textContent = state.avg_specialization.toFixed(3);
            document.getElementById('totalActivationsMetric').textContent = state.total_activations;
            
            // Update blockchain metrics
            if (network) {
                const balance = network.get_account_balance();
                document.getElementById('accountBalanceMetric').textContent = balance.toFixed(2);
                
                const blockchainStats = network.get_blockchain_stats();
                if (blockchainStats) {
                    document.getElementById('totalBlocksMetric').textContent = blockchainStats.total_blocks;
                    document.getElementById('memoryCapsulesMetric').textContent = blockchainStats.total_memory_capsules;
                }
            }
        }
        
        // Visualization functions
        function drawActivityChart() {
            const canvas = document.getElementById('activityChart');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (activityHistory.length < 2) return;
            
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            const maxVal = Math.max(...activityHistory);
            const minVal = Math.min(...activityHistory);
            const range = maxVal - minVal || 1;
            
            for (let i = 0; i < activityHistory.length; i++) {
                const x = (i / (activityHistory.length - 1)) * canvas.width;
                const y = canvas.height - ((activityHistory[i] - minVal) / range) * canvas.height;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            
            ctx.stroke();
            
            // Draw error history
            if (errorHistory.length > 1) {
                ctx.strokeStyle = '#ff6b6b';
                ctx.lineWidth = 1;
                ctx.beginPath();
                
                const maxError = Math.max(...errorHistory);
                const minError = Math.min(...errorHistory);
                const errorRange = maxError - minError || 1;
                
                for (let i = 0; i < errorHistory.length; i++) {
                    const x = (i / (errorHistory.length - 1)) * canvas.width;
                    const y = canvas.height - ((errorHistory[i] - minError) / errorRange) * canvas.height;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.stroke();
            }
        }
        
        function drawTopologyChart(nodeCount, connectionCount) {
            const canvas = document.getElementById('topologyChart');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (nodeCount === 0) return;
            
            // Draw nodes in a circle
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(canvas.width, canvas.height) / 3;
            
            const nodes = [];
            for (let i = 0; i < nodeCount; i++) {
                const angle = (i / nodeCount) * 2 * Math.PI;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                nodes.push({ x, y });
            }
            
            // Draw connections (simplified)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            const connectionsPerNode = Math.min(3, Math.floor(connectionCount / nodeCount));
            
            for (let i = 0; i < nodeCount; i++) {
                for (let j = 1; j <= connectionsPerNode; j++) {
                    const targetIndex = (i + j) % nodeCount;
                    ctx.beginPath();
                    ctx.moveTo(nodes[i].x, nodes[i].y);
                    ctx.lineTo(nodes[targetIndex].x, nodes[targetIndex].y);
                    ctx.stroke();
                }
            }
            
            // Draw nodes
            ctx.fillStyle = '#FFD93D';
            for (const node of nodes) {
                ctx.beginPath();
                ctx.arc(node.x, node.y, 6, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

        function drawBlockchainChart() {
            const canvas = document.getElementById('blockchainChart');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (!network) return;
            
            const stats = network.get_blockchain_stats();
            if (!stats) return;
            
            // Draw simple blockchain visualization
            const blockWidth = 40;
            const blockHeight = 30;
            const blockSpacing = 10;
            const startX = 20;
            const startY = canvas.height / 2;
            
            ctx.fillStyle = '#FFD93D';
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 2;
            
            for (let i = 0; i < Math.min(stats.total_blocks, 10); i++) {
                const x = startX + i * (blockWidth + blockSpacing);
                const y = startY - blockHeight / 2;
                
                // Draw block
                ctx.fillRect(x, y, blockWidth, blockHeight);
                ctx.strokeRect(x, y, blockWidth, blockHeight);
                
                // Draw block number
                ctx.fillStyle = '#000';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(i.toString(), x + blockWidth/2, y + blockHeight/2 + 4);
                ctx.fillStyle = '#FFD93D';
                
                // Draw connection to next block
                if (i < Math.min(stats.total_blocks - 1, 9)) {
                    ctx.beginPath();
                    ctx.moveTo(x + blockWidth, y + blockHeight/2);
                    ctx.lineTo(x + blockWidth + blockSpacing, y + blockHeight/2);
                    ctx.stroke();
                }
            }
            
            // Draw stats text
            ctx.fillStyle = '#FFF';
            ctx.font = '14px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`Blocks: ${stats.total_blocks}`, 20, 30);
            ctx.fillText(`Transactions: ${stats.total_transactions}`, 20, 50);
            ctx.fillText(`Memory Capsules: ${stats.total_memory_capsules}`, 20, 70);
            ctx.fillText(`Accounts: ${stats.total_accounts}`, 20, 90);
        }
        
        // Event handlers
        document.getElementById('createCluster').addEventListener('click', () => {
            const deviceId = document.getElementById('deviceId').value;
            const clusterId = document.getElementById('clusterId').value;
            const nodeCount = parseInt(document.getElementById('nodeCount').value);
            
            if (!network) {
                network = new DistributedNeuralNetwork(deviceId);
                addLog(`Created network for device: ${deviceId}`, 'blockchain');
            }
            
            const success = network.create_cluster(clusterId, nodeCount);
            if (success) {
                addLog(`Created cluster '${clusterId}' with ${nodeCount} nodes`);
                setStatus('üü¢ Network ready', 'ready');
                
                // Update visualization
                const state = network.get_cluster_state(clusterId);
                if (state) {
                    updateMetrics(state);
                    drawTopologyChart(nodeCount, state.num_connections);
                    drawBlockchainChart();
                }
            } else {
                addLog('Failed to create cluster', 'error');
            }
        });
        
        document.getElementById('processInput').addEventListener('click', () => {
            if (!network) {
                addLog('Create a network first!', 'error');
                return;
            }
            
            const clusterId = document.getElementById('clusterId').value;
            const inputStr = document.getElementById('inputData').value;
            const inputData = inputStr.split(',').map(x => parseFloat(x.trim()));
            
            const outputs = network.process_input(clusterId, inputData);
            const avgOutput = outputs.reduce((sum, val) => sum + val, 0) / outputs.length;
            
            activityHistory.push(avgOutput);
            if (activityHistory.length > 100) {
                activityHistory.shift();
            }
            
            addLog(`Processed input: [${inputData.join(', ')}] ‚Üí avg output: ${avgOutput.toFixed(4)}`);
            
            // Update metrics
            const state = network.get_cluster_state(clusterId);
            if (state) {
                updateMetrics(state);
                drawTopologyChart(state.num_nodes, state.num_connections);
            }
            
            drawActivityChart();
            drawBlockchainChart();
        });
        
        document.getElementById('updateError').addEventListener('click', () => {
            if (!network) {
                addLog('Create a network first!', 'error');
                return;
            }
            
            const clusterId = document.getElementById('clusterId').value;
            const error = parseFloat(document.getElementById('errorSignal').value);
            
            network.update_error_signal(clusterId, error);
            
            errorHistory.push(Math.abs(error));
            if (errorHistory.length > 100) {
                errorHistory.shift();
            }
            
            addLog(`Updated error signal: ${error}`);
            drawActivityChart();
        });
        
        document.getElementById('stepSimulation').addEventListener('click', () => {
            if (!network) {
                addLog('Create a network first!', 'error');
                return;
            }
            
            network.step_simulation(1.0);
            addLog('Stepped simulation forward');
            
            // Update metrics
            const clusterId = document.getElementById('clusterId').value;
            const state = network.get_cluster_state(clusterId);
            if (state) {
                updateMetrics(state);
            }
        });

        document.getElementById('borrowNode').addEventListener('click', () => {
            if (!network) {
                addLog('Create a network first!', 'error');
                return;
            }
            
            const nodeOwner = document.getElementById('nodeOwner').value;
            const duration = parseFloat(document.getElementById('borrowDuration').value);
            const nodeId = 'remote_node_001';
            
            const borrowingId = network.request_node_borrowing(nodeOwner, nodeId, duration);
            if (borrowingId) {
                addLog(`‚úÖ Node borrowing approved: ${borrowingId}`, 'blockchain');
                updateMetrics({ num_nodes: 0, num_connections: 0, avg_specialization: 0, total_activations: 0 });
            } else {
                addLog('‚ùå Node borrowing request denied', 'error');
            }
        });

        document.getElementById('mineBlock').addEventListener('click', () => {
            if (!network) {
                addLog('Create a network first!', 'error');
                return;
            }
            
            const blockHash = network.mine_block();
            if (blockHash) {
                addLog(`‚õèÔ∏è Mined new block: ${blockHash}`, 'blockchain');
                drawBlockchainChart();
                updateMetrics({ num_nodes: 0, num_connections: 0, avg_specialization: 0, total_activations: 0 });
            } else {
                addLog('No pending transactions to mine', 'warning');
            }
        });

        document.getElementById('validateChain').addEventListener('click', () => {
            if (!network) {
                addLog('Create a network first!', 'error');
                return;
            }
            
            const isValid = network.validate_blockchain();
            if (isValid) {
                addLog('‚úÖ Blockchain validation passed', 'blockchain');
            } else {
                addLog('‚ùå Blockchain validation failed!', 'error');
            }
        });
        
        // P2P Networking event handlers
        document.getElementById('startDiscovery').addEventListener('click', () => {
            if (network) {
                const success = network.start_peer_discovery();
                if (success) {
                    addLog('üîç Started peer discovery protocol', 'p2p');
                    setStatus('üåê Discovering peers', 'connecting');
                } else {
                    addLog('‚ùå Failed to start peer discovery', 'error');
                }
            }
        });

        document.getElementById('connectPeer').addEventListener('click', () => {
            const peerInfo = document.getElementById('peerConnectionInfo').value;
            if (network && peerInfo) {
                try {
                    const peerData = JSON.parse(peerInfo);
                    const success = network.connect_to_peer(peerData.device_id, peerInfo);
                    if (success) {
                        addLog(`ü§ù Connected to peer: ${peerData.device_id}`, 'p2p');
                        setStatus('üåê P2P connected', 'ready');
                    } else {
                        addLog(`‚ùå Failed to connect to peer: ${peerData.device_id}`, 'error');
                    }
                } catch (e) {
                    addLog('‚ùå Invalid peer connection info JSON', 'error');
                }
            }
        });

        document.getElementById('requestNodeFromPeer').addEventListener('click', () => {
            const peerId = document.getElementById('peerIdForRequest').value;
            if (network && peerId) {
                const requestId = network.request_node_from_peer(peerId, 'inference', 30);
                if (requestId) {
                    addLog(`üì§ Requested node from peer ${peerId}, request ID: ${requestId}`, 'p2p');
                } else {
                    addLog(`‚ùå Failed to request node from peer: ${peerId}`, 'error');
                }
            }
        });

        document.getElementById('shareMemoryWithPeer').addEventListener('click', () => {
            const peerId = document.getElementById('peerIdForRequest').value;
            const clusterId = document.getElementById('clusterId').value;
            if (network && peerId && clusterId) {
                const success = network.share_memory_with_peer(peerId, clusterId);
                if (success) {
                    addLog(`üíæ Shared memory capsule with peer: ${peerId}`, 'p2p');
                } else {
                    addLog(`‚ùå Failed to share memory with peer: ${peerId}`, 'error');
                }
            }
        });

        document.getElementById('startCollabLearning').addEventListener('click', () => {
            const peerList = document.getElementById('collaborativePeers').value;
            const taskDesc = document.getElementById('taskDescription').value;
            if (network && peerList && taskDesc) {
                const peerIds = peerList.split(',').map(p => p.trim());
                const sessionId = network.start_collaborative_learning(peerIds, taskDesc);
                if (sessionId) {
                    addLog(`üéØ Started collaborative learning session: ${sessionId}`, 'p2p');
                    addLog(`üìö Task: ${taskDesc}`, 'training');
                    addLog(`üë• Participants: ${peerIds.length}`, 'training');
                } else {
                    addLog('‚ùå Failed to start collaborative learning', 'error');
                }
            }
        });

        document.getElementById('propagateError').addEventListener('click', () => {
            const clusterId = document.getElementById('clusterId').value;
            const urgency = parseInt(document.getElementById('errorUrgency').value);
            if (network && clusterId) {
                const propagatedCount = network.propagate_error_to_peers(clusterId, urgency);
                addLog(`üì° Error propagated to ${propagatedCount} peers (urgency: ${urgency})`, 'p2p');
            }
        });

        // Update P2P network visualization
        function updateP2PNetworkStats() {
            if (!network) return;

            try {
                const stats = network.get_p2p_network_stats();
                if (stats) {
                    document.getElementById('connectedPeers').textContent = stats.connected_peers || 0;
                    document.getElementById('knownPeers').textContent = stats.known_peers || 0;
                    document.getElementById('pendingMessages').textContent = stats.pending_messages || 0;
                    document.getElementById('avgLatency').textContent = `${Math.round(stats.average_latency || 0)}ms`;
                    document.getElementById('networkHealth').textContent = `${Math.round((stats.network_health || 0) * 100)}%`;
                    
                    drawP2PStatsChart(stats);
                }
            } catch (e) {
                console.warn('Failed to update P2P stats:', e);
            }
        }

        function drawP2PStatsChart(stats) {
            const canvas = document.getElementById('p2pStatsChart');
            const ctx = canvas.getContext('2d');
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Background
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Network health visualization
            const healthPercent = (stats.network_health || 0) * 100;
            const healthColor = healthPercent > 70 ? '#4CAF50' : healthPercent > 40 ? '#FF9800' : '#F44336';
            
            // Health bar
            ctx.fillStyle = healthColor;
            ctx.fillRect(20, 20, (canvas.width - 40) * (healthPercent / 100), 30);
            
            // Health border
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(20, 20, canvas.width - 40, 30);
            
            // Health label
            ctx.fillStyle = '#fff';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`Network Health: ${Math.round(healthPercent)}%`, canvas.width / 2, 40);
            
            // Connection stats
            const connectedPeers = stats.connected_peers || 0;
            const knownPeers = stats.known_peers || 0;
            
            // Peer connection visualization
            ctx.fillStyle = '#00BCD4';
            ctx.fillRect(20, 70, Math.min(connectedPeers * 30, canvas.width - 40), 20);
            
            ctx.fillStyle = 'rgba(156, 39, 176, 0.5)';
            ctx.fillRect(20, 100, Math.min(knownPeers * 20, canvas.width - 40), 20);
            
            // Labels
            ctx.fillStyle = '#fff';
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`Connected: ${connectedPeers}`, 25, 85);
            ctx.fillText(`Known: ${knownPeers}`, 25, 115);
            
            // Latency indicator
            const avgLatency = stats.average_latency || 0;
            const latencyColor = avgLatency < 100 ? '#4CAF50' : avgLatency < 300 ? '#FF9800' : '#F44336';
            
            ctx.fillStyle = latencyColor;
            ctx.fillRect(20, 140, Math.min(avgLatency / 2, canvas.width - 40), 15);
            
            ctx.fillStyle = '#fff';
            ctx.fillText(`Avg Latency: ${Math.round(avgLatency)}ms`, 25, 152);
        }
        
        // Initialize WASM module
        async function initializeDemo() {
            try {
                await init();
                setStatus('üü¢ WASM module loaded successfully', 'ready');
                addLog('Distributed Neural Network with Blockchain WASM module initialized');
                addLog('Ready to create networks and process data');
                
                // Enable controls
                document.querySelectorAll('button').forEach(btn => btn.disabled = false);
                
            } catch (error) {
                setStatus('‚ùå Failed to load WASM module', 'error');
                addLog(`Error: ${error.message}`, 'error');
                console.error(error);
            }
        }
        
        // Start demo
        initializeDemo();
        
        // Auto-run demo after 2 seconds if user hasn't interacted
        setTimeout(() => {
            if (!network) {
                document.getElementById('createCluster').click();
                setTimeout(() => {
                    document.getElementById('processInput').click();
                }, 1000);
            }
        }, 2000);

        // Auto-update blockchain chart periodically
        setInterval(() => {
            if (network) {
                drawBlockchainChart();
                updateMetrics({ num_nodes: 0, num_connections: 0, avg_specialization: 0, total_activations: 0 });
            }
        }, 5000);

        // Main update loop
        function updateDisplay() {
            if (network) {
                const clusterId = document.getElementById('clusterId').value;
                if (clusterId) {
                    // Update existing metrics
                    const state = network.get_cluster_state(clusterId);
                    if (state) {
                        updateMetrics(state);
                        drawTopologyChart(state.num_nodes, state.num_connections);
                    }
                    
                    // Update blockchain metrics
                    updateBlockchainStats();
                    
                    // Update vector database stats
                    updateVectorDBStats();
                    
                    // Update P2P network stats
                    updateP2PNetworkStats();
                    
                    // Process training
                    network.step_simulation(16.0); // ~60fps
                }
            }
        }
    </script>
</body>
</html> 